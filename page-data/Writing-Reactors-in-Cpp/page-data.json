{"componentChunkName":"component---src-templates-docs-js","path":"/Writing-Reactors-in-Cpp","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Gitbook Boilerplate | Hasura","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"848d80ad-eeb8-51a3-9149-b6bfd17cd4d6","title":"Writing Reactors In Cpp","slug":"/Writing-Reactors-in-Cpp"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In the C++ reactor target for Lingua Franca, reactions are written in C++ and the code generator generates a standalone C++ program that can be compiled and run on all major platforms. Our continous integration ensures compatibility with Windows, MacOS and Linux.\\nThe C++ target solely depends on a working C++ build system including a recent C++ compiler (supporting C++17) and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://cmake.org/\"\n  }, \"CMake\"), \" (>= 3.5). It relies on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tud-ccc/reactor-cpp\"\n  }, \"reactor-cpp\"), \" runtime, which is automatically fetched and compiled in the background by the Lingua Franca compiler.\"), mdx(\"p\", null, \"Note that C++ is not a safe language. There are many ways that a programmer can circumvent the semantics of Lingua Franca and introduce nondeterminism and illegal memory accesses. For example, it is easy for a programmer to mistakenly send a message that is a pointer to data on the stack. The destination reactors will very likely read invalid data. It is also easy to create memory leaks, where memory is allocated and never freed. Note, however, that the C++ reactor library is designed to prevent common errors and to encourage a safe modern C++ style. Here, we introduce the specifics of writing Reactor programs in C++ and present some guidelines for a style that will be safe.\"), mdx(\"h2\", null, \"Setup\"), mdx(\"p\", null, \"The following tools are required in order to compile the generated C++ source code:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A recent C++ compiler supporting C++17\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A recent version of cmake (At least 3.5)\")), mdx(\"h2\", null, \"A Minimal Example\"), mdx(\"p\", null, \"A \\\"hello world\\\" reactor for the C++ target looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target Cpp;\\n\\nmain reactor {\\n    reaction(startup) {=\\n        std::cout << \\\"Hello World!\\\\n\\\";\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"startup\"), \" action is a special \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/wiki/Language-Specification#Action-Declaration\"\n  }, \"action\"), \" that triggers at the start of the program execution causing the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/wiki/Language-Specification#Reaction-Declaration\"\n  }, \"reaction\"), \" to execute. This program can be found in a file called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/Minimal.lf\"\n  }, \"Minimal.lf\"), \" in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/tree/master/test/Cpp\"\n  }, \"test directory\"), \", where you can also find quite a few more interesting examples. If you compile this using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"downloading-and-building#Command-Line-Tools\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"lfc\"), \" command-line compiler\"), \" or the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"downloading-and-building#Download-the-Integrated-Development-Environment\"\n  }, \"Eclipse-based IDE\"), \", then generated source files will be put into a subdirectory called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src-gen/Minimal\"), \". In addition, an executable binary will be compiled using your system's C++ compiler. The resulting executable will be called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minimial\"), \" and be put in a subdirectory called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bin\"), \". If you are in the C++ test directory, you can execute it in a shell as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" bin/Minimal\\n\")), mdx(\"p\", null, \"The resulting output should look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"[INFO]  Starting the execution\\nHello World!\\n[INFO]  Terminating the execution\\n\")), mdx(\"h2\", null, \"The C++ Target Specification\"), mdx(\"p\", null, \"To have Lingua Franca generate C++ code, start your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file with the following target specification:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target Cpp;\\n\")), mdx(\"p\", null, \"A C++ target specification may optionally include the following parameters:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"build-type \\\"type\\\"\"), \": The \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"build type\"), \" to be used by the C++ compiler. This can be any of Release, Debug, RelWithDebInfo and MinSizeRel. It defaults to Release.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cmake-include \\\"file\\\"\"), \": An optional \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"file\"), \" to be included by the generated cmake build system. This gives control over the way LF programs are build and allows for instance to include and link to external libraries. (See \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/xtext/org.icyphy.linguafranca/src/test/Cpp/AsyncCallback.lf\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"AsyncCallvack.lf\")), \" for an example)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"compiler \\\"command\\\"\"), \": The \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"command\"), \" to use to compile the generated code. Normally CMake selects the best compiler for your system, but you can use this parameter to point it to your preferred compiler.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"external-runtime-path \\\"path\\\"\"), \": When specified, the resulting binary links to a pre-compiled external runtime library located in \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"path\"), \"  instead of the default one.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fast [true|false]\"), \": Whether to execute as fast as possible ignoring real time. This defaults to false.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"keepalive [true|false]\"), \": Whether to continue executing even when there are no events on the event queue. The default is false. Usually, you will want to set this to true when you have \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"physical action\"), \"s.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"logging [ERROR|WARN|INF|DEBUG]\"), \": The level of diagnostic messages about execution to print to the console. A message will print if this parameter is greater than or equal to the level of the message (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ERROR\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WARN\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"INFO\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DEBUG\"), \"). \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"no-compile [true|false]\"), \": If this is set to true, then the Lingua Franca compiler will only generate code and not run the C++ compiler. This defaults to false.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"no-runtime-validation [true|false]\"), \": If this is set to true, then all runtime checks in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/tud-ccc/reactor-cpp\"\n  }, \"reactor-cpp\"), \" will be disabled. This brings a slight performance boost but should be used with care and only on tested programs. This defaults to false.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"runtime-version \\\"version\\\"\"), \": Specify the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"version\"), \" of the runtime library the compiled binary should link against. \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"version\"), \" can be any tag, branch name or git hash in the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/tud-ccc/reactor-cpp\"\n  }, \"reactor-cpp\"), \" repository.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"threads <n>\"), \": The number of worker threads \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"n\"), \" that are used to execute reactions. This is required to be a positive integer. If this is not specified or set to zero, then the number of worker threads will be set to the number of hardware threads of the executing system. If this is set to one, the scheduler will not create any worker threads and instead inline the execution of reactions. This is an optimization and avoids any unnecessary synchronization. Note that, in contrast to the C target, the single threaded implementation is still thread safe and asynchronous reaction scheduling is supported.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"timeout <n> <unit>\"), \": The amount of logical time to run before exiting. By default, the program will run forever or until forcibly stopped, with control-C, for example.\")), mdx(\"h2\", null, \"Command-Line Arguments\"), mdx(\"p\", null, \"The generated C++ program understands the following command-line arguments, each of which has a short form (one character) and a long form:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-f, --fast\"), \":  If set, then the program will execute as fast as possible, letting logical time advance faster than physical time.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-o, --timeout '<duration> <units>'\"), \": Stop execution when logical time has advanced by the specified \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"duration\"), \". The units can be any of nsec, usec, msec, sec, minute, hour, day, week, or the plurals of those.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-k, --keepalive\"), \": If set, then the program will keep executing until either the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"timeout\"), \" logical time is reached or the program is externally killed. If you have \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"physical action\"), \"s, it usually makes sense to set this.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-t, --threads <n>\"), \": Use n worker threads for executing reactions.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-h, --help\"), \": Print the above information.\")), mdx(\"p\", null, \"If the main reactor declares parameters, these parameters will appear as additional CLI options that can be specified when invoking the binary (see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#using-parameters\"\n  }, \"Using Parameters\"), \").\"), mdx(\"h2\", null, \"Imports\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"Language-Specification#import-statement\"\n  }, \"import statement\"), \" can be used to share reactor definitions across several applications. Suppose for example that we modify the above Minimal.lf program as follows and store this in a file called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/HelloWorld.lf\"\n  }, \"HelloWorld.lf\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target Cpp;\\nreactor HelloWorld {\\n    reaction(startup) {=\\n        std::cout << \\\"Hello World.\\\\n\\\";\\n    =}\\n}\\nmain reactor HelloWorldTest {\\n    a = new HelloWorld();\\n}\\n\")), mdx(\"p\", null, \"This can be compiled and run, and its behavior will be identical to the version above.\\nBut now, this can be imported into another reactor definition as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target Cpp;\\nimport HelloWorld.lf;\\nmain reactor TwoHelloWorlds {\\n    a = new HelloWorld();\\n    b = new HelloWorld();\\n}\\n\")), mdx(\"p\", null, \"This will create two instances of the HelloWorld reactor, and when executed, will print \\\"Hello World\\\" twice.\"), mdx(\"p\", null, \"Note that in the above example, the order in which the two reactions are invoked is undefined\\nbecause there is no causal relationship between them. In fact, you might see garbled output as on default multiple worker threads are used to execute the program and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::cout\"), \" is not thread safe. You can restrict execution to one thread if you modify the target specification to say:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target Cpp {threads: 1};\\n\")), mdx(\"p\", null, \"A more interesting illustration of imports can be found in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/Import.lf\"\n  }, \"Import.lf\"), \" test case.\"), mdx(\"h2\", null, \"Preamble\"), mdx(\"p\", null, \"Reactions may contain arbitrary C++ code, but often it is convenient for that code to invoke external libraries or to share type and/or method definitions.  For either purpose, a reactor may include a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"preamble\"), \" section. For example, the following reactor uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"atoi\"), \" from the common \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stdlib\"), \" C library to convert a string to an integer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor Preamble {\\n    private preamble {=\\n        include <cstdlib>\\n    =}\\n    timer t;\\n    reaction(t) {=\\n        char* s = \\\"42\\\";\\n        int i = atoi(s);\\n        std::cout << \\\"Converted string << s << \\\" to nt \\\" << i << '\\\\n';\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This will print:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Converted string 42 to int 42.\\n\")), mdx(\"p\", null, \"By putting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#include\"), \" in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"preamble\"), \", the library becomes available in all reactions of this reactor. Note the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"private\"), \" qualifier before the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"preamble\"), \" keyword. This ensures that the preamble is only visible to the reactions defined in this reactor and not to any other reactors. In contrast, the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public\"), \" qualifier ensures that the preamble is also visible to other reactors in files that import the reactor defining the public preamble.\"), mdx(\"p\", null, \"See for instance the reactor in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/Preamble.lf\"\n  }, \"Preamble.lf\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Preamble {\\n    public preamble {=\\n        struct MyStruct {\\n            int foo;\\n            std::string bar;\\n        };\\n    =}\\n    \\n    private preamble {=\\n        int add_42(int i) {\\n            return i + 42;\\n        }\\n    =}\\n\\n    logical action a:MyStruct;\\n    \\n    reaction(startup) {=\\n        a.schedule({add_42(42), \\\"baz\\\"});\\n    =}\\n\\n    reaction(a) {=\\n        auto& value = *a.get();\\n        std::cout << \\\"Received \\\" << value.foo << \\\" and '\\\" << value.bar << \\\"'\\\\n\\\"; \\n    =}\\n}\\n\\n\")), mdx(\"p\", null, \"It defines both, a public and a private preamble. The public preamble defines the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyStruct\"), \". This type definition will be visible to all elements of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Preamble\"), \" reactor as well as to all reactors defined in files that import \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Preamble\"), \". The private preamble defines the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add_42(int i)\"), \". This function will only be usable to reactions within the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Preamble\"), \" reactor.\"), mdx(\"p\", null, \"You can think of public and private preambles as the equivalent of header files and source files in C++. In fact, the public preamble will be translated to a header file and the private preamble to a source file. As a rule of thumb, all types that are used in port or action definitions as well as in state variables or parameters should be defined in a public preamble. Also declarations of functions to be shared across reactors should be placed in the public preamble. Everything else, like function definitions or types that are used only within reactions should be placed in a private preamble.\"), mdx(\"p\", null, \"Note that preambles can also be specified on the file level. These file level preambles are visible to all reactors within the file. An example of this can be found in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/target/PreambleFile.lf\"\n  }, \"PreambleFile.lf\"), \".\"), mdx(\"p\", null, \"Admittedly, the precise interactions of preambles and imports can become confusing. The preamble mechanism will likely be refined in future revisions.\"), mdx(\"p\", null, \"Note that functions defined in the preamble cannot access members such as state variables of the reactor unless they are explicitly passed as arguments. If access to the inner state of a reactor is required, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/wiki/Writing-Reactors-in-Cpp#using-methods\"\n  }, \"methods\"), \" present a viable and easy to use alternative.\"), mdx(\"h2\", null, \"Reactions\"), mdx(\"p\", null, \"Recall that a reaction is defined within a reactor using the following syntax:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reaction\"), \"(\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"triggers\"), \") \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"uses\"), \" -> \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"effects\"), \" {=\", mdx(\"br\", null), \"\\n\", \"\\xA0\", \"\\xA0\", \" ... target language code ... \", mdx(\"br\", null), \"\\n=}\")), mdx(\"p\", null, \"In this section, we explain how \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"triggers\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"uses\"), \", and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"effects\"), \" variables work in the C++ target.\"), mdx(\"h3\", null, \"Inputs and Outputs\"), mdx(\"p\", null, \"In the body of a reaction in the C++ target, the value of an input is obtained using the syntax \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*name.get()\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" is the name of the input port. Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get()\"), \" always returns a pointer to the actual value. Thus the pointer needs to be dereferenced with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" to obtain the value. (See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#sending-and-receiving-large-data-types\"\n  }, \"Sending and Receiving Large Data Types\"), \" for an explanation of the exact mechanisms behind this pointer access).\\nTo determine whether an input is present, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name.is_present()\"), \" can be used. Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get()\"), \" returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nullptr\"), \" if no value is present, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name.get() != nullptr\"), \" can be used alternatively for checking presence.\"), mdx(\"p\", null, \"For example, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/Determinism.lf\"\n  }, \"Determinism.lf\"), \" test case in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/tree/master/test/Cpp\"\n  }, \"test directory\"), \" includes the following reactor:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Destination {\\n\")), mdx(\"p\", null, \"   \\t    input x:int;\\ninput y:int;\\nreaction(x, y) {=\\nint sum = 0;\\nif (x.is_present()) {\\nsum += \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x.get();\\n}\\nif (y.is_present()) {\\nsum += \"), \"y.get();\\n}\\nstd::cout << \\\"Received \\\" << sum << std::endl;\\n=}\\n}\"), mdx(\"p\", null, \"The reaction refers to the inputs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \" and tests for the presence of values using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x.is_present()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y.is_present()\"), \".  If a reaction is triggered by just one input, then normally it is not necessary to test for its presence; it will always be present. But in the above example, there are two triggers, so the reaction has no assurance that both will be present.\"), mdx(\"p\", null, \"Inputs declared in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"uses\"), \" part of the reaction do not trigger the reaction. Consider this modification of the above reaction:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reaction(x) y {=\\n    int sum = *x.get();\\n    if (y.is_present()) {\\n        sum += *y.get();\\n    }\\n    std::cout << \\\"Received \\\" << sum << std::endl;\\n=}\\n\")), mdx(\"p\", null, \"It is no longer necessary to test for the presence of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" because that is the only trigger. The input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \", however, may or may not be present at the logical time that this reaction is triggered. Hence, the code must test for its presence.\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"effects\"), \" portion of the reaction specification can include outputs and actions. Actions will be described below. Outputs are set using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \" method on an output port. For example, we can further modify the above example as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"output z:int;\\nreaction(x) y -> z {=\\n    int sum = *x.get();\\n    if (y.is_present()) {\\n        sum += *y.get();\\n    }\\n    z.set(sum);\\n=}\\n\")), mdx(\"p\", null, \"If an output gets set more than once at any logical time, downstream reactors will see only the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"final\"), \" value that is set. Since the order in which reactions of a reactor are invoked at a logical time is deterministic, and whether inputs are present depends only on their timestamps, the final value set for an output will also be deterministic.\"), mdx(\"p\", null, \"An output may even be set in different reactions of the same reactor at the same logical time. In this case, one reaction may wish to test whether the previously invoked reaction has set the output. It can check \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name.is_present()\"), \" to determine whether the output has been set. For example, the following reactor (see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/TestForPreviousOutput.lf\"\n  }, \"TestForPreviousOutput.lf\"), \") will always produce the output 42:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Source {\\n    output out:int;\\n    reaction(startup) -> out {=\\n        // Set a seed for random number generation based on the current time.\\n        std::srand(std::time(nullptr));\\n        // Randomly produce an output or not.\\n        if (std::rand() % 2) {\\n            out.set(21);\\n        }\\n    =}\\n    reaction(startup) -> out {=\\n        if (out.is_present()) {\\n            int previous_output = *out.get();\\n            out.set(2 * previous_output);\\n        } else {\\n            out.set(42);\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The first reaction may or may not set the output to 21. The second reaction doubles the output if it has been previously produced and otherwise produces 42.\"), mdx(\"h3\", null, \"Using State Variables\"), mdx(\"p\", null, \"A reactor may declare state variables, which become properties of each instance of the reactor. For example, the following reactor (see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/lib/Count.lf\"\n  }, \"Count.lf\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/CountTest.lf\"\n  }, \"CountTest.lf\"), \") will produce the output sequence 1, 2, 3, ... :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Count {\\n    state i:int(0);\\n    output c:int;\\n    timer t(0, 1 sec);\\n    reaction(t) -> c {=\\n        i++;\\n        c.set(i);\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The declaration on the second line gives the variable the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \", declares its type to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \", and initializes its value to 0. The type and initial value can be enclosed in the C++-code delimiters \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{= ... =}\"), \" if they are not simple identifiers, but in this case, that is not necessary.\"), mdx(\"p\", null, \"In the body of the reaction, the state variable is automatically in scope and can be referenced directly by its name. Since all reactions, state variables and also parameters of a reactor are members of the same class, reactions can also reference state variables (or parameters) using the this pointer: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this->name\"), \".\"), mdx(\"p\", null, \"A state variable may be a time value, declared as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"state time_value:time(100 msec);\\n\")), mdx(\"p\", null, \"The type of the generated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time_value\"), \" variable will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::Duration\"), \", which is an alias for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/chrono/duration\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std::chrono::nanoseconds\")), \".\"), mdx(\"p\", null, \"For the C++ target, Lingua Franca provides two alternative styles for initializing state variables. We can write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state foo:int(42)\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state foo:int{42}\"), \". This allows to distinguish between the different initialization styles in C++. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo:int(42)\"), \" will be translated to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int foo(42)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \" foo:int{42}\"), \" will be translated to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int foo{42}\"), \" in the generated code. Generally speaking, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{...}\"), \" style should be preffered in C++, but it is not always applicable. Hence we allow the LF programmer to choose the style. Due to the peculiarities of C++, this is particularly important for more complex data types. For instance, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state foo:std::vector<int>(4,2)\"), \" would be initialized to the list \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[2,2,2,2]\"), \" whereas \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state foo:std::vector<int>{4,2}\"), \" would be initialized to the list \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[4,2]\"), \".\"), mdx(\"p\", null, \"State variables can have array values. For example, the \", \"[MovingAverage]\", \" (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/MovingAverage.lf\"\n  }, \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/MovingAverage.lf\"), \") reactor computes the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"moving average\"), \" of the last four inputs each time it receives an input:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor MovingAverageImpl {\\n    state delay_line:double[3]{0.0, 0.0, 0.0};\\n    state index:int(0);\\n    input in:double;\\n    output out:double;\\n\\n    reaction(in) -> out {=\\n        // Calculate the output.\\n        double sum = *in.get();\\n        for (int i = 0; i < 3; i++) {\\n            sum += delay_line[i];\\n        }\\n        out.set(sum/4.0);\\n\\n        // Insert the input in the delay line.\\n        delay_line[index] = *in.get();\\n\\n        // Update the index for the next input.\\n        index++;\\n        if (index >= 3) {\\n            index = 0;\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The second line declares that the type of the state variable is an fixed-size array of 3 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"double\"), \"s with the initial value of the being filled with zeros (note the curly braces). If the size is given in the type specification, then the code generator will declare the type of the state variable using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/container/array\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std::array\")), \". In the example above, the type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"delay_line\"), \" is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::array<3, double>\"), \". If the size specifier is omitted (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state x:double[]\"), \"). The code generator will produce a variable-sized array using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/container/vector\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std::vector\")), \".\"), mdx(\"p\", null, \"State variables with more complex types such as classes or structs can be similiarly initialized. See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/StructAsState.lf\"\n  }, \"StructAsState.lf\"), \".\"), mdx(\"h3\", null, \"Using Parameters\"), mdx(\"p\", null, \"Reactor parameters work similar to state variables in C++. However, they are always declared as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" and initialized during reactor instantiation. Thus, the value of a parameter may not be changed. For example, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/Stride.lf\"\n  }, \"Stride\"), \" reactor modifies the above \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Count\"), \" reactor so that its stride is a parameter:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Count(stride:int(1)) {\\n    state count:int(0);\\n    output y:int;\\n    timer t(0, 100 msec);\\n    reaction(t) -> y {=\\n        y.set(count);\\n        count += stride;\\n    =}\\n}\\nreactor Display {\\n    input x:int;\\n    reaction(x) {=\\n        std::cout << \\\"Received \\\" << *x.get() << std::endl;\\n    =}\\n}\\nmain reactor Stride {\\n    c = new Count(stride = 2);\\n    d = new Display();\\n    c.y -> d.x;\\n}\\n\")), mdx(\"p\", null, \"The first line defines the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stride\"), \" parameter, gives its type, and gives its initial value. As with state variables, the type and initial value can be enclosed in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{= ... =}\"), \" if necessary.\"), mdx(\"p\", null, \"When the reactor is instantiated, the default parameter value can be overridden. This is done in the above example near the bottom with the line:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"c = new Count(stride = 2);\\n\")), mdx(\"p\", null, \"If there is more than one parameter, use a comma separated list of assignments.\"), mdx(\"p\", null, \"Also parameters can have fixed- or variable-sized array values. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/C/ArrayAsParameter.lf\"\n  }, \"ArrayAsParameter\"), \" example  outputs the elements of an array as a sequence of individual messages:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Source(sequence:int[]{0, 1, 2}) {\\n    output out:int;\\n    state count:int(0);\\n    logical action next:void;\\n    reaction(startup, next) -> out, next {=\\n        out.set(sequence[count]);\\n        count++;\\n        if (count < sequence.size()) {\\n            next.schedule();\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"logical action\"), \" named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule\"), \" method are explained below in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#Scheduling-Delayed-Reactions\"\n  }, \"Scheduling Delayed Reactions\"), \"; here they are used simply to repeat the reaction until all elements of the array have been sent. Note that similiar aas for state variables, curly braces \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{...}\"), \" can optionally be used for initialization.\"), mdx(\"p\", null, \"Note that also the main reactor can be parameterized:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor Hello(msg:string(\\\"World\\\")) {\\n    reaction(startup) {=\\n        std::cout << \\\"Hello \\\" << msg << \\\"!\\\\n\\\";\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This program will print \\\"Hello World!\\\" by default. However, since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg\"), \" is a main reactor parameter, the C++ code generator will extend the CLI argument parser and allow to overwrite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg\"), \" when invoking the program. For instance,\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"bin/Hello --msg Earth\\n\")), mdx(\"p\", null, \"will result in \\\"Hello Earth!\\\" being printed.\"), mdx(\"h3\", null, \"Using Methods\"), mdx(\"p\", null, \"Sometimes reactors need to perform certain operations on state variables and/or parameters that are shared between reactions or that are too complex to be implemented in a single reaction. In such cases, methods can be defined within reactors to facilitate code reuse and enable a better structuring of the reactor's functionality. Analogous to class methods, methods in LF can access all state variables and parameters, and can be invoked from all reaction bodies or from other methods. Consdider the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/target/Method.lf\"\n  }, \"Method\"), \" example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor {\\n    state foo:int(2);\\n     \\n    const method getFoo(): int {=\\n        return foo;\\n    =}\\n    \\n    method add(x:int) {=\\n        foo += x;\\n    =}\\n      \\n    reaction(startup){=\\n        std::cout << \\\"Foo is initialized to \\\" << getFoo() << '\\\\n';\\n        add(40);\\n        std::cout << \\\"2 + 40 = \\\" << getFoo() << '\\\\n';\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This reactor defines two methods \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getFoo\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getFoo\"), \" is quailfied as a const method, which indicates that it has read-only access to the state variables. This is direclty translated to a C++ const method in the code generation process. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getFoo\"), \" receives no arguments and returns an integer (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \") indicating the current value of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" state variable. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" returns nothing (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"void\"), \") and receives one interger argument, which it uses to increment \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \". Both methods are visible in all reactions of the reactor. In this example, the reactio to startup calles both methods in order ro read and modify its state.\"), mdx(\"h3\", null, \"Sending and Receiving Large Data Types\"), mdx(\"p\", null, \"You can define your own datatypes in C++ or use types defined in a library and send and receive those. Consider the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/StructAsType.lf\"\n  }, \"StructAsType\"), \" example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor StructAsType {\\n    public preamble {=\\n        struct Hello {\\n            std::string name;\\n            int value;\\n        };\\n    =}\\n    \\n    output out:Heloo;\\n    reaction(startup) -> out {=\\n        Hello hello{\\\"Earth, 42};\\n        out.set(hello);\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"preamble\"), \" code defines a struct datatype. In the reaction to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"startup\"), \", the reactor creates an instance of this struct on the stack (as a local variable named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hello\"), \") and then copies that instance to the output using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \" method. For this reason, the C++ reactor runtime provides more sophisticated ways to allocate objects and send them via ports.\"), mdx(\"p\", null, \"The C++ library defines two types of smart pointers that the runtime uses internally to implement the exchange of data between ports. These are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::MutableValuePtr<T>\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::ImmutableValuePtr<T>\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::MutableValuePtr<T>\"), \" is a wrapper around \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std::unique_ptr\")), \" and provides read and write access to the value hold, while ensuring that the value has a unique owner. In contrast, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::ImmutableValuePtr<T>\"), \" is a wrapper around \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std::shared_pointer\")), \" and provides read only (const) access to the value it holds. This allows data to be shared between reactions of various reactors, while guarantee data consistency. Similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::make_unique\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::make_shared\"), \", the reactor library provides convenient function for creating mutable and immutable values pointers: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::make_mutable_value<T>(...)\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::make_immutable_value<T>(...)\"), \".\"), mdx(\"p\", null, \"In fact this code from the example above:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Hello hello{\\\"Earth, 42};\\nout.set(hello);\\n\")), mdx(\"p\", null, \"implicitly invokes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::make_immutable_value<Hello>(hello)\"), \" and could be rewritten as\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Hello hello{\\\"Earth, 42};\\nout.set(reactor::make_immutable_value<Hello>(hello));\\n\")), mdx(\"p\", null, \"This will invoke the copy constructor of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Hello\"), \", copying its conten from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hello\"), \" instance to the newly created \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::ImmutableValuePtr<Hello>\"), \".\"), mdx(\"p\", null, \"Since copying large objects is inefficient, the move semantics of C++ can be used to move the ownership of object instead of copying it. This can be done in the following two ways. First, by directly creating a mutable or immutable value pointer, where a mutable pointer allows modification of the object after it has been created:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"auto hello = reactor::make_mutable_value<Hello>(\\\"Earth\\\", 42);\\nhello->name = \\\"Mars\\\";\\nout.set(std::move(hello));\\n\")), mdx(\"p\", null, \"An example of this can be found in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/StructPrint.lf\"\n  }, \"StructPrint.lf\"), \". Not that after the call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::move\"), \", hello is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nullptr\"), \" and the reaction cannot modify the object anymore. Alternatively, if no modification is requires, the object can be instantiated directly in the call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set()\"), \" as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"out.set({\\\"Earth\\\", 42});\\n\")), mdx(\"p\", null, \"An example of this can be found in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/StructAsTypeDirect.lf\"\n  }, \"StructAsTypeDirect\"), \".\"), mdx(\"p\", null, \"Getting a value from an input port of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get()\"), \" always returns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::ImmutableValuePtr<T>\"), \". This ensures that the value cannot be modified by multiple reactors receiving the same value, as this could lead to an inconsistent state and nondeterminism in a multi-threaded execution. An immutable value pointer can be converted to a mutable pointer by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_mutable_copy\"), \". For instance, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/ArrayScale.lf\"\n  }, \"ArrayScale\"), \" reactor modifies elements of the array it receives before sending it to the next reactor:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Scale(scale:int(2)) {\\n    input in:int[3];\\n    output out:int[3];\\n\\n    reaction(in) -> out {=\\n        auto array = in.get().get_mutable_copy();\\n        for(int i = 0; i < array->size(); i++) {\\n            (*array)[i] = (*array)[i] * scale;\\n        }\\n        out.set(std::move(array));\\n    =}\\n}\\n\")), mdx(\"p\", null, \"Currently \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_mutable_copy()\"), \" always copies the contained value to safely create a mutable pointer. However, a future implementation could optimize this by checking if any other reaction is accessing the same value. If not, the value can simply be moved from the immutable pointer to a mutable one.\"), mdx(\"h2\", null, \"Timed Behavior\"), mdx(\"p\", null, \"Timers are specified exactly as in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"Language-Specification#timer-declaration\"\n  }, \"Lingua Franca language specification\"), \". When working with time in the C++ code body of a reaction, however, you will need to know a bit about its internal representation.\"), mdx(\"p\", null, \"The Reactor C++ library uses \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/chrono\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std::chrono\")), \" for representing time. Specifically, the library defines two types for representing durations and timepoints: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::Duration\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::TimePoint\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::Duration\"), \" is an alias for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/chrono/duration\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std::chrono::nanosecods\")), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::TimePoint\"), \" is alias for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/chrono/time_point\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds>\")), \". As you can see from these definitions, the smallest time step that can be represented is one nanosecond. Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::TimePoint\"), \" describes a specific point in time and is associated with a specific clock, whereas \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::Duration\"), \" defines a time interval between two time points.\"), mdx(\"p\", null, \"Lingua Franca uses a superdense model of logical time.  A reaction is invoked at a logical \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"tag\"), \". In the C++ library, a tag is represented by the class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::Tag\"), \". In essence, this class is a tuple of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::TimePoint\"), \" representing a specific point in logical time and a microstep value (of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::mstep_t\"), \", which is an alias for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unsigned long\"), \"). \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::Tag\"), \" provides two methods for getting the time point or the microstep:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const TimePoint& time_point() const;\\nconst mstep_t& micro_step() const;\\n\")), mdx(\"p\", null, \"The C++ code in reaction bodies has access to library functions that allow to retrieve the current logical or physical time:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TimePoint get_physical_time()\"), \": Get the current physical time.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TimePoint get_logcial_time()\"), \": Get the current logical time.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Duration get_elapsed_physical_time()\"), \": Get the physical time elapsed since program start.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Duration get_elapsed_logical_time()\"), \": Get the logical time elapsed since program start.\")), mdx(\"p\", null, \"A reaction can examine the current logical time (which is constant during the execution of the reaction). For example, consider the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/GetTime.lf\"\n  }, \"GetTime\"), \" example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor {\\n    timer t(0, 1 sec);\\n    reaction(t) {=\\n        auto logical = get_logical_time();\\n        std::cout << \\\"Logical time is \\\" << logical << std::endl;\\n    =}\\n}\\n\")), mdx(\"p\", null, \"Note that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<<\"), \" operator is overloaded for both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::TimePoint\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::Duration\"), \" and will print the time information accordingly.\"), mdx(\"p\", null, \"When executing the above program, you will see something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"[INFO]  Starting the execution\\nLogical time is 2021-05-19 14:06:09.496828396\\nLogical time is 2021-05-19 14:06:10.496828396\\nLogical time is 2021-05-19 14:06:11.496828396\\nLogical time is 2021-05-19 14:06:11.496828396\\n...\\n\")), mdx(\"p\", null, \"If you look closely, you will see that each printed logical time is one second larger than the previous one.\"), mdx(\"p\", null, \"You can also obtain the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"elapsed\"), \" logical time since the start of execution:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor {\\n    timer t(0, 1 sec);\\n    reaction(t) {=\\n        auto elapsed = get_elapsed_logical_time();\\n        std::cout << \\\"Elapsed logical time is \\\" << elapsed << std::endl;\\n        std::cout << \\\"In seconds: \\\" <<  std::chrono::duration_cast<std::chrono::seconds>(elapsed) << std::endl;\\n    =}\\n}\\n\")), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::chrono\"), \" it is also possible to convert between time units and directly print the number of elapsed seconds as seen above. The resulting output of this program will be:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"[INFO]  Starting the execution\\nElapsed logical time is 0 nsecs\\nIn seconds: 0 secs\\nElapsed logical time is 1000000000 nsecs\\nIn seconds: 1 secs\\nElapsed logical time is 2000000000 nsecs\\nIn seconds: 2 secs\\n...\\n\")), mdx(\"p\", null, \"You can also get physical and elapsed physical time:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor {\\n    timer t(0, 1 sec);\\n    reaction(t) {=\\n        auto logical = get_logical_time();\\n        auto physical = get_physical_time();\\n        auto elapsed = get_elapsed_physical_time();\\n        std::cout << \\\"Physical time is \\\" << physical << std::endl;\\n        std::cout << \\\"Elapsed physical time is \\\" << elapsed << std::endl;\\n        std::cout << \\\"Time lag is \\\" << physical - logical << std::endl;\\n   =}\\n}\\n\")), mdx(\"p\", null, \"Notice that the physical times are increasing by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"roughly\"), \" one second in each reaction. The output also shows the lag between physical and logical time. If you set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fast\"), \" target parameter to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \", then physical time will elapse much faster than logical time. The above program will produce something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"[INFO]  Starting the execution\\nPhysical time is 2021-05-19 14:25:18.070523014\\nElapsed physical time is 2601601 nsecs\\nTime lag is 2598229 nsecs\\nPhysical time is 2021-05-19 14:25:19.068038275\\nElapsed physical time is 1000113888 nsecs\\nTime lag is 113490 nsecs\\n[INFO]  Physical time is Terminating the execution\\n2021-05-19 14:25:20.068153026\\nElapsed physical time is 2000228689 nsecs\\nTime lag is 228241 nsecs\\n\")), mdx(\"p\", null, \"For specifying time durations in code \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/header/chrono\"\n  }, \"chrono\"), \" provides convenient literal operators in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::chrono_literals\"), \". This namespace is automatically included for all reaction bodies. Thus, we can simply write:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"std::cout << 42us << std::endl;\\nstd::cout << 1ms << std::endl;\\nstd::cout << 3s << std::endl;\\n\")), mdx(\"p\", null, \"which prints:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"42 usecs\\n1 msecs\\n3 secs\\n\")), mdx(\"h3\", null, \"Scheduling Delayed Reactions\"), mdx(\"p\", null, \"The C++ provides a simple interface for scheduling actions via a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \" method. Actions are described in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"language-specification#action-declaration\"\n  }, \"Language Specification\"), \" document. Consider the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/test/Cpp/src/Schedule.lf\"\n  }, \"Schedule\"), \" reactor:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Schedule {\\n    input x:int;\\n    logical action a;\\n    reaction(a) {=\\n         auto elapsed_time = get_elapsed_logical_time();\\n         std::cout << \\\"Action triggered at logical time \\\" << elapsed_time.count()\\n                  << \\\" after start\\\" << std::endl; elapsed_time);\\n    =}\\n    reaction(x) -> a {=\\n        a.schedule(200ms);\\n    =}\\n}\\n\")), mdx(\"p\", null, \"When this reactor receives an input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \", it calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \" on the action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \", specifying a logical time offset of 200 milliseconds. The action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" will be triggered at a logical time 200 milliseconds after the arrival of input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \". At that logical time, the second reaction will trigger and will use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_elapsed_logical_time()\"), \" function to determine how much logical time has elapsed since the start of execution.\"), mdx(\"p\", null, \"Notice that after the logical time offset of 200 msec, there may be another input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" simultaneous with the action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \". Because the reaction to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" is given first, it will execute first. This becomes important when such a reactor is put into a feedback loop (see below).\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TODO: Explain physical actions as well!\")), mdx(\"h3\", null, \"Zero-Delay Actions\"), mdx(\"p\", null, \"If the specified delay in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \" is omitted or is zero, then the action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" will be triggered one \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"microstep\"), \" later in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"superdense time\"), \" (see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"language-specification#superdense-time\"\n  }, \"Superdense Time\"), \"). Hence, if the input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" arrives at metric logical time \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \", and you call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \" in one of the following ways:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"a.schedule();\\na.schedule(0s);\\na.schedule(reactor::Duration::zero());\\n\")), mdx(\"p\", null, \"then when the reaction to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" is triggered, the input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" will be absent (it was present at the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"previous\"), \" microstep). The reaction to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and the reaction to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" occur at the same metric time \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \", but separated by one microstep, so these two reactions are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" logically simultaneous.\"), mdx(\"p\", null, \"As discussed above the he metric time is visible to the rogrammer and can be obtained in a reaction using either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_elapsed_logical_time()\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_logical_time()\"), \".\"), mdx(\"p\", null, \"As described in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"language-specification#action-declaration\"\n  }, \"Language Specification\"), \" document, action declarations can have a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"min_delay\"), \" parameter. This modifies the timestamp further. Also, the action declaration may be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"physical\"), \" rather than \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"logical\"), \", in which case, the assigned timestamp will depend on the physical clock of the executing platform.\"), mdx(\"h2\", null, \"Actions With Values\"), mdx(\"p\", null, \"If an action is declared with a data type, then it can carry a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"value\"), \", a data value that becomes available to any reaction triggered by the action.  This is particularly useful for physical actions that are externally triggered because it enables the action to convey information to the reactor. This could be, for example, the body of an incoming network message or a numerical reading from a sensor.\"), mdx(\"p\", null, \"Recall from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"language-specification#Contained-Reactors\"\n  }, \"Contained Reactors\"), \" section in the Language Specification document that the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"after\"), \" keyword on a connection between ports introduces a logical delay. This is actually implemented using a logical action. We illustrate how this is done using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tud-ccc/reactor-cpp/blob/master/include/reactor-cpp/logical_time.hh\"\n  }, \"DelayInt\"), \" example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Delay(delay:time(100 msec)) {\\n    input in:int;\\n    output out:int;\\n    logical action d:int;\\n    reaction(in) -> d {=\\n        d.schedule(in.get(), delay);\\n    =}\\n    reaction(d) -> out {=\\n        if (d.is_present()) {\\n            out.set(d.get());\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"Using this reactor as follows\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    d = new Delay();\\n    source.out -> d.in;\\n    d.in -> sink.out\\n\")), mdx(\"p\", null, \"is equivalent to\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    source.out -> sink.in after 100 msec\\n\")), mdx(\"p\", null, \"(except that our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Delay\"), \" reactor will only work with data type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \").\"), mdx(\"p\", null, \"The action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d\"), \" is specified with a type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \". The reaction to the input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \" declares as its effect the action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d\"), \". This declaration makes it possible for the reaction to schedule a future triggering of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d\"), \". In the C++ target, actions use the same mechanism for passing data via value pointers as do ports. In the example above, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reactor::ImmutablValuePtr<int>\"), \" derived by the call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in.get()\"), \" is passed directly to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \". Similarly, the value can later be retrieved from the action with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d.get()\"), \" and passed to the output port.\"), mdx(\"p\", null, \"The first reaction declares that it is triggered by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d\"), \" and has effect \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"out\"), \". Because this reaction is first, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"out\"), \" at any logical time can be produced before the input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \" is even known to be present. Hence, this reactor can be used in a feedback loop, where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"out\"), \" triggers a downstream reactor to send a message back to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \" of this same reactor. If the reactions were given in the opposite order, there would be causality loop and compilation would fail.\"), mdx(\"p\", null, \"If you are not sure whether an action carries a value, you can test for it using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"is_present()\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reaction(d) -> out {=\\n    if (d.is_present()) {\\n        out.set(d.get());\\n    }\\n=}\\n\")), mdx(\"p\", null, \"It is possible to both be triggered by and schedule an action the same reaction. For example, this reactor will produce a counting sequence after it is triggered the first time:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor CountSelf(delay:time(100 msec)) {\\n    output out:int;\\n    logical action a:int;\\n    reaction(startup) -> a, out {=\\n        out.set(0);\\n        a.schedule_int(1, delay);\\n    =}\\n    reaction(a) -> a, out {=\\n        out.set(a.get());\\n        a.schedule_int(*a.get() + 1, delay);\\n    =}\\n}\\n\")), mdx(\"p\", null, \"Of course, to produce a counting sequence, it would be more efficient to use a state variable.\"), mdx(\"h2\", null, \"Stopping Execution\"), mdx(\"p\", null, \"A reaction may request that the execution stops after all events with the current timestamp have been processed by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"environment()->sync_shutdown()\"), \". There is also a method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"environment()->async_shutdown()\"), \"\\nwhich may be invoked from outside an reaction, like an external thread.\"), mdx(\"h2\", null, \"Log and Debug Information\"), mdx(\"p\", null, \"The reactor-cpp library provides logging utilities in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tud-ccc/reactor-cpp/blob/master/include/reactor-cpp/logging.hh\"\n  }, \"logging.hh\"), \" for producing messages to be made visible when the generated program is run. Of course \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::cout\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"printf\"), \" can be used for the same purpose, but the logging mechanism provided by reactor-cpp is thread-safe ensuring that messages produced in parallel reactions are not interleaved with each other and provides common way for turning messages of a certain severity on and off.\"), mdx(\"p\", null, \"In particular, reactor-cpp provides the following logging interfaces:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reactor::Debug()\"), \": for verbose debug messages\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reactor:Info()\"), \": for info messages of general interest, info is the default severity level\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reactor::Warning()\"), \": for warning messages\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reactor::Error()\"), \": for errors\")), mdx(\"p\", null, \"These utilities can be used analogues to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::cout\"), \". For instance:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor::Info() << \\\"Hello World! It is \\\" << get_physical_time();\\n\")), mdx(\"p\", null, \"Note that unlike \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::cout\"), \" the new line delimiter is automatically added to the end of the message.\"), mdx(\"p\", null, \"Which type of messages are actually produced by the compiled program can be controlled with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"log-level\"), \" target property.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#setup","title":"Setup"},{"url":"#a-minimal-example","title":"A Minimal Example"},{"url":"#the-c-target-specification","title":"The C++ Target Specification"},{"url":"#command-line-arguments","title":"Command-Line Arguments"},{"url":"#imports","title":"Imports"},{"url":"#preamble","title":"Preamble"},{"url":"#reactions","title":"Reactions","items":[{"url":"#inputs-and-outputs","title":"Inputs and Outputs"},{"url":"#using-state-variables","title":"Using State Variables"},{"url":"#using-parameters","title":"Using Parameters"},{"url":"#using-methods","title":"Using Methods"},{"url":"#sending-and-receiving-large-data-types","title":"Sending and Receiving Large Data Types"}]},{"url":"#timed-behavior","title":"Timed Behavior","items":[{"url":"#scheduling-delayed-reactions","title":"Scheduling Delayed Reactions"},{"url":"#zero-delay-actions","title":"Zero-Delay Actions"}]},{"url":"#actions-with-values","title":"Actions With Values"},{"url":"#stopping-execution","title":"Stopping Execution"},{"url":"#log-and-debug-information","title":"Log and Debug Information"}]},"parent":{"relativePath":"Writing-Reactors-in-Cpp.md"},"frontmatter":{"metaTitle":null,"metaDescription":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Benchmarks","title":"Benchmarks"}}},{"node":{"fields":{"slug":"/A-future-proof-package-and-import-system","title":"A Future Proof Package And Import System"}}},{"node":{"fields":{"slug":"/Clone-the-Repository","title":"Clone The Repository"}}},{"node":{"fields":{"slug":"/Containerized-Execution","title":"Containerized Execution"}}},{"node":{"fields":{"slug":"/Contributing","title":"Contributing"}}},{"node":{"fields":{"slug":"/Creating-and-Managing-Submodules","title":"Creating And Managing Submodules"}}},{"node":{"fields":{"slug":"/Developer-IntelliJ-Setup-(for-Kotlin)","title":"Developer Intelli J Setup For Kotlin"}}},{"node":{"fields":{"slug":"/Diagrams","title":"Diagrams"}}},{"node":{"fields":{"slug":"/Distributed-Execution","title":"Distributed Execution"}}},{"node":{"fields":{"slug":"/Generic-Types,-Interfaces,-and-Inheritance","title":"Generic Types Interfaces And Inheritance"}}},{"node":{"fields":{"slug":"/Downloading-and-Building","title":"Downloading And Building"}}},{"node":{"fields":{"slug":"/Home","title":"Home"}}},{"node":{"fields":{"slug":"/Import-System","title":"Import System"}}},{"node":{"fields":{"slug":"/Legacy-Eclipse-Instructions","title":"Legacy Eclipse Instructions"}}},{"node":{"fields":{"slug":"/Maven-Notes","title":"Maven Notes"}}},{"node":{"fields":{"slug":"/Modal-Models-RFC","title":"Modal Models RFC"}}},{"node":{"fields":{"slug":"/Multiports-and-Banks-of-Reactors","title":"Multiports And Banks Of Reactors"}}},{"node":{"fields":{"slug":"/Overview","title":"Overview"}}},{"node":{"fields":{"slug":"/Protobufs","title":"Protobufs"}}},{"node":{"fields":{"slug":"/Publications-and-Presentations","title":"Publications And Presentations"}}},{"node":{"fields":{"slug":"/Regression-Tests","title":"Regression Tests"}}},{"node":{"fields":{"slug":"/Related-Work","title":"Related Work"}}},{"node":{"fields":{"slug":"/Results-of-Experiments-for-Rhythm","title":"Results Of Experiments For Rhythm"}}},{"node":{"fields":{"slug":"/Running-Benchmarks","title":"Running Benchmarks"}}},{"node":{"fields":{"slug":"/Running-Lingua-Franca-IDE-(Epoch)-with-Kotlin-based-Code-Generators-Enabled-(without-Eclipse-Environment)","title":"Running Lingua Franca IDE Epoch With Kotlin Based Code Generators Enabled Without Eclipse Environment"}}},{"node":{"fields":{"slug":"/Support-Matrix","title":"Support Matrix"}}},{"node":{"fields":{"slug":"/Tardiness","title":"Tardiness"}}},{"node":{"fields":{"slug":"/Target-Specification","title":"Target Specification"}}},{"node":{"fields":{"slug":"/Termination","title":"Termination"}}},{"node":{"fields":{"slug":"/Timing-Analysis","title":"Timing Analysis"}}},{"node":{"fields":{"slug":"/Tools","title":"Tools"}}},{"node":{"fields":{"slug":"/Troubleshooting","title":"Troubleshooting"}}},{"node":{"fields":{"slug":"/Using-Maven","title":"Using Maven"}}},{"node":{"fields":{"slug":"/Web-Based-Editor","title":"Web Based Editor"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Cpp","title":"Writing Reactors In Cpp"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Python","title":"Writing Reactors In Python"}}},{"node":{"fields":{"slug":"/","title":"Landing Page"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-TypeScript","title":"Writing Reactors In Type Script"}}}]}},"pageContext":{"id":"848d80ad-eeb8-51a3-9149-b6bfd17cd4d6"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}