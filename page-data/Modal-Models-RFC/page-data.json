{"componentChunkName":"component---src-templates-docs-js","path":"/Modal-Models-RFC","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Gitbook Boilerplate | Hasura","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"8525a3aa-612e-5ebb-8c9e-ee74a3567466","title":"Modal Models RFC","slug":"/Modal-Models-RFC"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Possible concept for supporting modes in LF.\"), mdx(\"h2\", null, \"Motivation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Structured behavior\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Both in text and diagrams\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Built-in state machines\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dependencies\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Accept cyclic dependencies if involved reactions are mutually exclusive.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Verification\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mode-dependent invariants / conditions\")))), mdx(\"h3\", null, \"Synthetic Examples\"), mdx(\"p\", null, \"[\", \"[img/modal_models_rfc/motor.png | width=450px]\", \"]\"), mdx(\"p\", null, \"Separating reaction 2 and 3 of the Controller reactor into mutually exclusive modes could allow to ensure via static verification that at no time the Motor reactor receives a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fwd\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rev\"), \" input simultaneously.\"), mdx(\"p\", null, \"[\", \"[img/modal_models_rfc/cyclic_dep.png | width=250px]\", \"]\"), mdx(\"p\", null, \"Separating reaction 2 and 3 of the Modes reactor into mutually exclusive modes could allow to accept this program.\"), mdx(\"h2\", null, \"Design Considerations\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"LF does not provide an expression/statement language.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Only Reactions can access variables and ports via the respective target language API and target code should not be analyzed.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Information about modes and their transitions must be available statically in LF to facilitate the dependency analysis and verification.\")), mdx(\"p\", null, \"For this proposal, the aim is (at least so far) not to create a state machine syntax with an abstract expression/statement language for triggers and effects that is compiled into target code but to reuse elements of the current polyglot approach.\"), mdx(\"h2\", null, \"Basic Syntax Proposal\"), mdx(\"p\", null, \"Reactors may contain (two or more) mode definitions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A mode provides a unique ID (in the reactor scope)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"May consist of (only for simplicity at this point):\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Reactions\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Reactor instantiations (under the same restrictions)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Connections\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It shares the scope with the reactor but not with other modes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"One mode must be marked as \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"initial\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor TwoModes {\\n  initial mode One {\\n    ...\\n  }\\n  mode Two {\\n    ...\\n  }\\n}\\n\")), mdx(\"p\", null, \"Reactions in modes may declare a transition to (one or more) modes.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This enables the use of target language API to set the next state (e.g. set_mode(X))\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reaction(trig) transition Two {=\\n  if (trig->value) {\\n    set_mode(Two)\\n  }\\n=}\\n\")), mdx(\"h3\", null, \"Graphical Syntax\"), mdx(\"p\", null, \"[\", \"[img/modal_models_rfc/sine_avg_max_modes.png | width=650px]\", \"]\"), mdx(\"p\", null, \"The example continuously collects 10 data samples of a sine wave and computes either the average or maximum. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/experimental/modal_models/SineAvgMax/sine_max_avg.lf\"\n  }, \"LF source code\"), \". It is based on this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://ptolemy.org/systems/models/modal/ModalSDF/index.html\"\n  }, \"Ptolemy model with modes\"), \".\"), mdx(\"p\", null, \"[\", \"[img/modal_models_rfc/sine_avg_max_pt2.png | width=500px]\", \"]\"), mdx(\"p\", null, \"Note that reactions 1 and 3 are identical and both collect a sequence into an array. This was done to mimic the structure in Ptolemy. An alternative design could separate this task into a single reaction outside the modes (following image, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/blob/master/experimental/modal_models/SineAvgMax/sine_max_avg_v2.lf\"\n  }, \"source code\"), \") or into a reactor either instantiated in each mode or preprocessing inputs for the ModalModel reactor.\"), mdx(\"p\", null, \"[\", \"[img/modal_models_rfc/sine_avg_max_v2_modes.png | width=650px]\", \"]\"), mdx(\"h2\", null, \"Possible Execution Model\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The initial mode will be active upon reactor startup. Others will be inactive.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"All reactions in inactive modes will not be triggered.\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Reactions will not enter reaction queue.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Includes reactions in contained reactor instances.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Q: What about \\\"relay reactions\\\" for connections, should the be suppressed as well?\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If at a logical time (t, m) \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(See Q1)\"), \" all reactions are finished and a different mode was set, the current mode will be deactivated and the new one will be activated. No newly activated reactions will be triggered based on current inputs \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(See Q1)\"), \". All contained modes will be reset to their initial state \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(See Q2 and Q5)\"), \". All internal events/actions previously scheduled by contents of this new mode will be removed \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(Q: Better freeze them and introduce a mode local time line?)\"), \".\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This could also be implemented by mutations, deleting the content of the deactivated mode and adding the content of the new mode.\")))), mdx(\"h2\", null, \"Questions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Q1:\"), \" When to switch modes? 4 alternatives ordered by \\\"immediacy\\\":\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Immediate\"), \": This will switch modes immediately such that source and target mode will be active simultaneously. This will primarily prescribe an order for the reactions in modes instead of establishing mutual exclusion. \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Micro Step\"), \" (current proposal): If a new mode is set at (t, m) this mode will be active at (t, m + 1).\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Logical Time\"), \": Only one mode is active at all micro steps of a logical time tag t. The main question is at what time will be the next reaction, as this might depend on external inputs.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Explicit Delay\"), \": Setting a mode takes an explicit delay (like schedule) when to take the transition. Problem here is invalidating scheduled transitions by earlier ones.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Q2:\"), \" Do we want hierarchy?\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Proposal: Yes!\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Q3:\"), \" Hybrid Reactions\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mixing modes and reaction outside of modes in the same reactor (not done in Ptolemy/SCADE/SCCharts).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Might facilitate proper startup / shutdown of a reactor.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Q4:\"), \" Preemption\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Triggering transitions by reactions requires an active mode. This allows \\\"weak\\\" preemption but rules out \\\"strong\\\" preemption.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Executing all reactions allows overruling previously set target modes. This might be unintuitive compared to transitions and priorities. An \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"alternative\"), \" might be stopping reaction execution when a mode switch was triggered.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Q5:\"), \" Do we want history transitions?\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What about reacting to events/actions scheduled in previous activations of a mode?\")))), mdx(\"h2\", null, \"Observations\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Having reactions with transition dependencies in modes allows to infer outgoing transitions of this mode.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Using reactor instances in modes allows to model hierarchical modes.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Having the actual triggering of an transition in reaction code only exposes which reaction triggers \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"might\"), \" trigger the transition.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Marking modes as initial in LF enables proper code generation for a hierarchical reset. A more flexible \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"alternative\"), \" would be setting the initial mode in startup reactions. This would allow different initial states but would require target code parsing.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Restricting use of modes in reactions (set_mode) may require target code parsing.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Triggering transitions in a deadline block of a reaction corresponds to error transitions (Ptolemy).\"))), mdx(\"h2\", null, \"Possible Extensions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Actions:\"), \" Might be trivial as reactions to actions will be suppressed if mode is inactive. Actions scheduled in the future must be removed when entering mode. \")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Local State Variables\"), \": Requires initial value or a special reset reaction to properly reset the state when mode is reentered.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Timers:\"), \": Start/Restart when mode is entered. Feasibility depends on the timing of mode activation activation \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(See Q1)\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"History Transitions:\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Do not remove events/actions that were scheduled when the state was previously active.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Do not reset modes in contained reactors to initial (deep history)?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Omit triggering reset actions for state variables.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Timers are restored, not restarted.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Immediate Transitions:\"), \" See \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Q1\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Entry/Exit Triggers:\"), \" Special trigger for reactions to pre/post-process entering/leaving of modes.\"))), mdx(\"h2\", null, \"Optional Syntactic Sugar for (flat) FSMs\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor TwoModes {\\n  initial state One {...} //<-- optional (would introduce hierarchy)\\n  transition(TRIG) READ -> WRITE to Two \\n    if {= GUARD =} //<-- optional\\n    with {= EFFECT =} //<-- optional\\n\\n  state Two\\n}\\n\")), mdx(\"p\", null, \"Transformed into:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"initial mode One {\\n  reaction ($TRIG) $READ -> $WRITE transition Two {=\\n    if ($GUARD) { //<-- target language specific code generation\\n      set_mode(Two)\\n      $EFFECT //<-- Does not work with multiple triggering transitions as all effects would be executed (not only taken transtions, see Q4)\\n    }\\n  =}\\n}\\nmode Two {\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#motivation","title":"Motivation","items":[{"url":"#synthetic-examples","title":"Synthetic Examples"}]},{"url":"#design-considerations","title":"Design Considerations"},{"url":"#basic-syntax-proposal","title":"Basic Syntax Proposal","items":[{"url":"#graphical-syntax","title":"Graphical Syntax"}]},{"url":"#possible-execution-model","title":"Possible Execution Model"},{"url":"#questions","title":"Questions"},{"url":"#observations","title":"Observations"},{"url":"#possible-extensions","title":"Possible Extensions"},{"url":"#optional-syntactic-sugar-for-flat-fsms","title":"Optional Syntactic Sugar for (flat) FSMs"}]},"parent":{"relativePath":"Modal-Models-RFC.md"},"frontmatter":{"metaTitle":null,"metaDescription":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Benchmarks","title":"Benchmarks"}}},{"node":{"fields":{"slug":"/A-future-proof-package-and-import-system","title":"A Future Proof Package And Import System"}}},{"node":{"fields":{"slug":"/Clone-the-Repository","title":"Clone The Repository"}}},{"node":{"fields":{"slug":"/Containerized-Execution","title":"Containerized Execution"}}},{"node":{"fields":{"slug":"/Contributing","title":"Contributing"}}},{"node":{"fields":{"slug":"/Creating-and-Managing-Submodules","title":"Creating And Managing Submodules"}}},{"node":{"fields":{"slug":"/Developer-IntelliJ-Setup-(for-Kotlin)","title":"Developer Intelli J Setup For Kotlin"}}},{"node":{"fields":{"slug":"/Diagrams","title":"Diagrams"}}},{"node":{"fields":{"slug":"/Distributed-Execution","title":"Distributed Execution"}}},{"node":{"fields":{"slug":"/Generic-Types,-Interfaces,-and-Inheritance","title":"Generic Types Interfaces And Inheritance"}}},{"node":{"fields":{"slug":"/Downloading-and-Building","title":"Downloading And Building"}}},{"node":{"fields":{"slug":"/Home","title":"Home"}}},{"node":{"fields":{"slug":"/Import-System","title":"Import System"}}},{"node":{"fields":{"slug":"/Legacy-Eclipse-Instructions","title":"Legacy Eclipse Instructions"}}},{"node":{"fields":{"slug":"/Maven-Notes","title":"Maven Notes"}}},{"node":{"fields":{"slug":"/Modal-Models-RFC","title":"Modal Models RFC"}}},{"node":{"fields":{"slug":"/Multiports-and-Banks-of-Reactors","title":"Multiports And Banks Of Reactors"}}},{"node":{"fields":{"slug":"/Overview","title":"Overview"}}},{"node":{"fields":{"slug":"/Protobufs","title":"Protobufs"}}},{"node":{"fields":{"slug":"/Publications-and-Presentations","title":"Publications And Presentations"}}},{"node":{"fields":{"slug":"/Regression-Tests","title":"Regression Tests"}}},{"node":{"fields":{"slug":"/Related-Work","title":"Related Work"}}},{"node":{"fields":{"slug":"/Results-of-Experiments-for-Rhythm","title":"Results Of Experiments For Rhythm"}}},{"node":{"fields":{"slug":"/Running-Benchmarks","title":"Running Benchmarks"}}},{"node":{"fields":{"slug":"/Running-Lingua-Franca-IDE-(Epoch)-with-Kotlin-based-Code-Generators-Enabled-(without-Eclipse-Environment)","title":"Running Lingua Franca IDE Epoch With Kotlin Based Code Generators Enabled Without Eclipse Environment"}}},{"node":{"fields":{"slug":"/Support-Matrix","title":"Support Matrix"}}},{"node":{"fields":{"slug":"/Tardiness","title":"Tardiness"}}},{"node":{"fields":{"slug":"/Target-Specification","title":"Target Specification"}}},{"node":{"fields":{"slug":"/Termination","title":"Termination"}}},{"node":{"fields":{"slug":"/Timing-Analysis","title":"Timing Analysis"}}},{"node":{"fields":{"slug":"/Tools","title":"Tools"}}},{"node":{"fields":{"slug":"/Troubleshooting","title":"Troubleshooting"}}},{"node":{"fields":{"slug":"/Using-Maven","title":"Using Maven"}}},{"node":{"fields":{"slug":"/Web-Based-Editor","title":"Web Based Editor"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Cpp","title":"Writing Reactors In Cpp"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Python","title":"Writing Reactors In Python"}}},{"node":{"fields":{"slug":"/","title":"Landing Page"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-TypeScript","title":"Writing Reactors In Type Script"}}}]}},"pageContext":{"id":"8525a3aa-612e-5ebb-8c9e-ee74a3567466"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}