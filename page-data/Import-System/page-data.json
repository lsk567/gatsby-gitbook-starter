{"componentChunkName":"component---src-templates-docs-js","path":"/Import-System","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Gitbook Boilerplate | Hasura","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"57e91c05-ae48-514e-84b3-ea3d0a82e6e0","title":"Import System","slug":"/Import-System"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The following topics are meant as collections of design ideas, with the purpose of refining them into concrete design proposals.\")), mdx(\"h1\", null, \"Current Implementation of Imports\"), mdx(\"p\", null, \"The import functionality in Lingua Franca is limited to:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import HelloWorld.lf\\n\")), mdx(\"p\", null, \"This can be useful if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file is located in the same directory as the file containing the main reactor.\"), mdx(\"p\", null, \"However, several shortcomings exist in this current system which we shall discuss next.\"), mdx(\"h2\", null, \"Duplicate Reactor Names\"), mdx(\"p\", null, \"Reactors with the same name can cause issues. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import CatsAndPuppies.lf // Contains a Puppy reactor\\nimport MeanPuppies.lf   // Contains another Puppy reactor\\n\")), mdx(\"p\", null, \"There is no way for the LF program to distinguish between the two \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Puppy\"), \" reactors.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note.\"), \" With a relatively trivial extension to the current LF import mechanism, it is possible to detect duplicates, but there is no way to circumvent them in the current LF program (i.e., the original names might have to be changed).\"), mdx(\"h2\", null, \"Selective Importing\"), mdx(\"p\", null, \"Selective importing is not possible. For example, using\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import CatsAndPuppies.lf\\n\")), mdx(\"p\", null, \"will import all the reactors contained in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file. It would be desirable to selectively import a subset of reactors in another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file.\"), mdx(\"h2\", null, \"Qualified Paths\"), mdx(\"p\", null, \"Currently, there is no elegant way of importing modules that are not in the same directory.\"), mdx(\"h2\", null, \"Renaming\"), mdx(\"p\", null, \"All the reactors imported will have the name originally given to them by the original programmer. It might make sense to rename them for the current LF program.\"), mdx(\"h2\", null, \"Packages\"), mdx(\"p\", null, \"With the current import solution that only uses files, implementing packages in Lingua Franca is not feasible.\"), mdx(\"h1\", null, \"Proposed Solution\"), mdx(\"p\", null, \"With inspirations from Python, we propose the following import mechanism:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\"import\\\" LF_Trunc_File/module (\\\",\\\" LF_Trunc_File/module)* \\n              | \\\"from\\\" LFTruncFile/module \\\"import\\\" reactor [\\\"as\\\" name]\\n                (\\\",\\\" reactor [\\\"as\\\" name] )*\\n              | \\\"from\\\" LF_Trunc_File/module \\\"import\\\" \\\"*\\\" \\n\")), mdx(\"p\", null, \"Before discussing some examples, let's discuss \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LF_Trunc_File/module\"), \". First and foremost, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LF_Truc_File\"), \" stands for Lingua Franca Truncated File, which is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name.lf\"), \" file with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" removed. Therefore, the legacy support for import can be carried over as:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import HelloWorld\\n\")), mdx(\"p\", null, \"Second, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"module\"), \" would introduce the notion of packages to Lingua Franca. The content of a module can be located in any path. To enable this facility, modules provide a Lingua Franca Meta file (LFM) that introduces the package name, and the absolute or relative paths of all the LF files that are included in that package. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// CatsAndPuppies.LFM\\npackage CatsAndPuppies // Optional. The file name would be interpreted as the package name.\\nimport /home/user/linguafranca/pets/Cats.lf // Absolute paths\\nimport pets/Puppies.lf // Relative paths\\n\")), mdx(\"p\", null, \"For a package to be accessible, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LFM\"), \" file needs to be discoverable. For example, it can be automatically added to the current directory or \\\"installed\\\" in a known Lingua Franca path (e.g., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/usr/local/LF/packages\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/home/user/linguafranca/packages\"), \").\"), mdx(\"p\", null, \"With that in mind, let's discuss some examples on how this might work next.\\nThe content of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HelloWorld.lf\"), \" example is as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target C; \\nreactor SayHello {\\n    timer t;\\n    reaction(t) {=\\n        printf(\\\"Hello World.\\\\n\\\");\\n    =}\\n}\\nmain reactor HelloWorldTest {\\n    a = new HelloWorld();\\n}\\n\")), mdx(\"p\", null, \"Let us create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Greetings.lf\"), \" program based on HelloWorld.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target C; \\nimport HelloWorld\\n\\nmain reactor Greetings {\\n    a = new SayHello();\\n}\\n\")), mdx(\"p\", null, \"To generate code for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Greetings.lf\"), \", Lingua Franca first searches for a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HelloWorld.lf\"), \" file in the same directory as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Greetings.lf\"), \". If not found, it will look for a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HelloWorld.LFM\"), \" in the known paths. If none is found, an error is raised.\"), mdx(\"p\", null, \"Now we can demonstrate selective import. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target C; \\nfrom HelloWorld import SayHello\\n\\nmain reactor Greetings {\\n    a = new SayHello();\\n}\\n\")), mdx(\"p\", null, \"Finally, renaming can be done by using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" predicate:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target C; \\nfrom HelloWorld import SayHello as SayGreetings\\n\\nmain reactor Greetings {\\n    a = new SayHeGreetings();\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#current-implementation-of-imports","title":"Current Implementation of Imports","items":[{"url":"#duplicate-reactor-names","title":"Duplicate Reactor Names"},{"url":"#selective-importing","title":"Selective Importing"},{"url":"#qualified-paths","title":"Qualified Paths"},{"url":"#renaming","title":"Renaming"},{"url":"#packages","title":"Packages"}]},{"url":"#proposed-solution","title":"Proposed Solution"}]},"parent":{"relativePath":"Import-System.md"},"frontmatter":{"metaTitle":null,"metaDescription":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Benchmarks","title":"Benchmarks"}}},{"node":{"fields":{"slug":"/A-future-proof-package-and-import-system","title":"A Future Proof Package And Import System"}}},{"node":{"fields":{"slug":"/Clone-the-Repository","title":"Clone The Repository"}}},{"node":{"fields":{"slug":"/Containerized-Execution","title":"Containerized Execution"}}},{"node":{"fields":{"slug":"/Contributing","title":"Contributing"}}},{"node":{"fields":{"slug":"/Creating-and-Managing-Submodules","title":"Creating And Managing Submodules"}}},{"node":{"fields":{"slug":"/Developer-IntelliJ-Setup-(for-Kotlin)","title":"Developer Intelli J Setup For Kotlin"}}},{"node":{"fields":{"slug":"/Diagrams","title":"Diagrams"}}},{"node":{"fields":{"slug":"/Distributed-Execution","title":"Distributed Execution"}}},{"node":{"fields":{"slug":"/Generic-Types,-Interfaces,-and-Inheritance","title":"Generic Types Interfaces And Inheritance"}}},{"node":{"fields":{"slug":"/Downloading-and-Building","title":"Downloading And Building"}}},{"node":{"fields":{"slug":"/Home","title":"Home"}}},{"node":{"fields":{"slug":"/Import-System","title":"Import System"}}},{"node":{"fields":{"slug":"/Legacy-Eclipse-Instructions","title":"Legacy Eclipse Instructions"}}},{"node":{"fields":{"slug":"/Maven-Notes","title":"Maven Notes"}}},{"node":{"fields":{"slug":"/Modal-Models-RFC","title":"Modal Models RFC"}}},{"node":{"fields":{"slug":"/Multiports-and-Banks-of-Reactors","title":"Multiports And Banks Of Reactors"}}},{"node":{"fields":{"slug":"/Overview","title":"Overview"}}},{"node":{"fields":{"slug":"/Protobufs","title":"Protobufs"}}},{"node":{"fields":{"slug":"/Publications-and-Presentations","title":"Publications And Presentations"}}},{"node":{"fields":{"slug":"/Regression-Tests","title":"Regression Tests"}}},{"node":{"fields":{"slug":"/Related-Work","title":"Related Work"}}},{"node":{"fields":{"slug":"/Results-of-Experiments-for-Rhythm","title":"Results Of Experiments For Rhythm"}}},{"node":{"fields":{"slug":"/Running-Benchmarks","title":"Running Benchmarks"}}},{"node":{"fields":{"slug":"/Running-Lingua-Franca-IDE-(Epoch)-with-Kotlin-based-Code-Generators-Enabled-(without-Eclipse-Environment)","title":"Running Lingua Franca IDE Epoch With Kotlin Based Code Generators Enabled Without Eclipse Environment"}}},{"node":{"fields":{"slug":"/Support-Matrix","title":"Support Matrix"}}},{"node":{"fields":{"slug":"/Tardiness","title":"Tardiness"}}},{"node":{"fields":{"slug":"/Target-Specification","title":"Target Specification"}}},{"node":{"fields":{"slug":"/Termination","title":"Termination"}}},{"node":{"fields":{"slug":"/Timing-Analysis","title":"Timing Analysis"}}},{"node":{"fields":{"slug":"/Tools","title":"Tools"}}},{"node":{"fields":{"slug":"/Troubleshooting","title":"Troubleshooting"}}},{"node":{"fields":{"slug":"/Using-Maven","title":"Using Maven"}}},{"node":{"fields":{"slug":"/Web-Based-Editor","title":"Web Based Editor"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Cpp","title":"Writing Reactors In Cpp"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Python","title":"Writing Reactors In Python"}}},{"node":{"fields":{"slug":"/","title":"Landing Page"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-TypeScript","title":"Writing Reactors In Type Script"}}}]}},"pageContext":{"id":"57e91c05-ae48-514e-84b3-ea3d0a82e6e0"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}