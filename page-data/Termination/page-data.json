{"componentChunkName":"component---src-templates-docs-js","path":"/Termination","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Gitbook Boilerplate | Hasura","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"0b086bf2-7d15-5a45-b3a7-c7a27036c4c9","title":"Termination","slug":"/Termination"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"There are a number of subtleties associated with the termination of Lingua Franca programs, particularly with federated execution. For the purposes of this discussion, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"tag\"), \" refers to the tuple (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"logical time\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"microstep\"), \"). \"), mdx(\"p\", null, \"There are several ways to terminate a program:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Timeout\"), \": The program specifies the last logical time at which reactions should be triggered.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Starvation\"), \": At the conclusion of some tag, there are no events in the event queue at future tags.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Stop request\"), \": Some reaction requests that the program terminate.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"External signal\"), \": Program is terminated externally with control-C or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"kill\"), \".\")), mdx(\"p\", null, \"We address each of these in turn.\"), mdx(\"h2\", null, \"Timeout\"), mdx(\"p\", null, \"The target property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \" specifies the last logical time at which reactions should be triggered. The last invocation of reactions will be at tag (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \", 0). The subtleties:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Schedule\"), \": Any invocation of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule\"), \" that specifies a logical time greater than the timeout value is ignored. No event gets scheduled. Moreover, if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule\"), \" is invoked at logical time equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \", then it is again ignored because that would have resulted in an event with tag (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \", 1), which is greater than the final tag.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Shutdown reactions\"), \": Reactions that are triggered by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shutdown\"), \" will be triggered at tag (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \", 0). There may be many other reactions triggered at that same tag, and a shutdown reaction may produce outputs causing other reactions to be triggered, so there is no assurance that shutdown reactions are invoked last. However, if a shutdown reaction is the last reaction in a reactor, then it is assured of being the last reaction invoked \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"in that reactor\"), \" at that final tag.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"After\"), \": If at logical time \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \" a reaction sends an output over connection using the keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"after\"), \" with value \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"d\"), \" >= 0, and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \" + \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"d\"), \" >\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \", then the output is dropped. No event gets scheduled. If \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"d\"), \" = 0 and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \" = \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \", the output is also dropped because that would have resulted in an event with tag (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \", 1), which is greater than the final tag. In a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"federated\"), \" execution, no message is launched into the network if  \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \" + \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"d\"), \" >\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Physical connections\"), \": A connection using the syntax \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"~>\"), \" specifies that the tag at the receiving end of the connection will be based on the physical time at which the message is received. See [\", \"[Physical Connections]\", \"] for the specification for how the tag is assigned at the receiving end. If the tag assigned at the receiving end is greater than (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \", 0), then the message is lost. Hence, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"messages sent near the \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"timeout\"), \" time are likely to be lost!\")))), mdx(\"h2\", null, \"Starvation\"), mdx(\"p\", null, \"If the target property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keepalive\"), \" is not specified or is set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" (the default), then a Lingua Franca program will exit after completing a logical tag if there are no future events scheduled. If there is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"timer\"), \" anywhere in the program, then this condition never occurs. There is always a future event scheduled (unless the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \" has been reached).  If there is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"physical action\"), \" anywhere in the program (and there is no timer), then you will need to set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keepalive\"), \" to true to prevent the program from exiting while waiting for some external stimulus.\"), mdx(\"p\", null, \"Starvation termination is tricky to implement for federated execution, particularly when physical connections are used. It requires developing a distributed consensus. One way to accomplish this is for each federate to send a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"QUEUE_EMPTY\"), \" message to the RTI whenever its event queue is empty. The message will need to include a count of the total number of messages it has sent or received on each direct connection to another federate. When the RTI receives such a message from all federates, and the number of messages sent and received on each direct connection match, then the RTI can broadcast a shutdown message.\"), mdx(\"p\", null, \"A decentralized version of the same consensus is more challenging but will be necessary if there is no RTI running. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"FIXME\"), \": Proposals are welcome here.\"), mdx(\"h2\", null, \"Stop Request\"), mdx(\"p\", null, \"If a reaction calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"request_stop\"), \", then it is requesting that the program cease execution as soon as possible. In a non-federated execution, this cessation can occur in the next microstep. The current tag will be completed as normal. Then the tag will be advanced by one microstep, and reactions triggered by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shutdown\"), \" will be executed, along with any other reactions with triggers at that tag, with all reactions executed in precedence order.\"), mdx(\"p\", null, \"In a federated execution, things are more complicated. In general, it is not possible to cease execution in the next microstep because this would mean that every federate has a communication channel to every other with delay equal to one microstep. This this does not create a causality loop, but it means that all federates have to advance time in lockstep, which creates a global barrier synchronization that will likely kill performance. It will also make decentralized coordination impossible because the safe-to-process (STP) threshold for all federates will explode to infinity.\"), mdx(\"p\", null, \"For \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"centralized coordination\"), \", when a reaction in a federate calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stop\"), \", the federate sends a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"STOP_REQUEST\"), \" message to the RTI with its current timestamp \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \" as a payload. It then waits for a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"STOP_GRANTED\"), \" message with a timestamp payload \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \". During this wait, it must respond to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \" STOP_REQUEST\"), \" incoming messages from the RTI (and all other messages from the RTI). (It should be possible to complete the current logical time while waiting.) If \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \" > \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \", then it sets \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \" = \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \" and continues executing, using the timeout mechanism (see above) to stop. If \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \" = \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \", then it completes the current tag as normal but schedules on shutdown phase to occur one microstep later, as in the unfederated case.\"), mdx(\"p\", null, \"When the RTI receives a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"STOP_REQUEST\"), \" message from a federate, it forwards it to all other federates and waits for a reply from all.  Each reply will have a timestamp payload. The RTI chooses \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \", the largest of these timestamps, and sends a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"STOP_GRANTED\"), \" message to all federates with payload \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \".\"), mdx(\"p\", null, \"When a federate receives a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"STOP_REQUEST\"), \" message, it replies with its current logical time \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \" and waits for a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"STOP_GRANTED\"), \" message from the RTI, blocking all execution during the wait. When it gets the reply with payload \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \", if \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \" > \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \", then it sets \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \" = \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \" and continues executing, using the timeout mechanism (see above) to stop. If \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \" = \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \", then it completes the current tag as normal but schedules on shutdown phase to occur one microstep later, as in the unfederated case.\"), mdx(\"h2\", null, \"External Signal\"), mdx(\"p\", null, \"Each federate and the RTI should catch external signals to shut down in an orderly way.\"), mdx(\"p\", null, \"When a federate gets such an external signal (e.g. control-C), it should send a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"RESIGN\"), \" message to the RTI and an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EOF\"), \" (end of file) on each socket connection to another federate. It should then close all sockets and shut down. The RTI and all other federates should continue running until some other termination condition occurs.\"), mdx(\"p\", null, \"When the RTI gets such an external signal, it should broadcast a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"STOP_REQUEST\"), \" message to all federates, wait for their replies (with a timeout in case the federate or the network has failed), choose the maximum timestamp \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \" on the replies, broadcast a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"STOP_GRANTED\"), \" message to all federates with payload \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"s\"), \", and wait for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"LOGICAL_TIME_COMPLETE\"), \" messages as above.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#timeout","title":"Timeout"},{"url":"#starvation","title":"Starvation"},{"url":"#stop-request","title":"Stop Request"},{"url":"#external-signal","title":"External Signal"}]},"parent":{"relativePath":"Termination.md"},"frontmatter":{"metaTitle":null,"metaDescription":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Benchmarks","title":"Benchmarks"}}},{"node":{"fields":{"slug":"/A-future-proof-package-and-import-system","title":"A Future Proof Package And Import System"}}},{"node":{"fields":{"slug":"/Clone-the-Repository","title":"Clone The Repository"}}},{"node":{"fields":{"slug":"/Containerized-Execution","title":"Containerized Execution"}}},{"node":{"fields":{"slug":"/Contributing","title":"Contributing"}}},{"node":{"fields":{"slug":"/Creating-and-Managing-Submodules","title":"Creating And Managing Submodules"}}},{"node":{"fields":{"slug":"/Developer-IntelliJ-Setup-(for-Kotlin)","title":"Developer Intelli J Setup For Kotlin"}}},{"node":{"fields":{"slug":"/Diagrams","title":"Diagrams"}}},{"node":{"fields":{"slug":"/Distributed-Execution","title":"Distributed Execution"}}},{"node":{"fields":{"slug":"/Generic-Types,-Interfaces,-and-Inheritance","title":"Generic Types Interfaces And Inheritance"}}},{"node":{"fields":{"slug":"/Downloading-and-Building","title":"Downloading And Building"}}},{"node":{"fields":{"slug":"/Home","title":"Home"}}},{"node":{"fields":{"slug":"/Import-System","title":"Import System"}}},{"node":{"fields":{"slug":"/Legacy-Eclipse-Instructions","title":"Legacy Eclipse Instructions"}}},{"node":{"fields":{"slug":"/Maven-Notes","title":"Maven Notes"}}},{"node":{"fields":{"slug":"/Modal-Models-RFC","title":"Modal Models RFC"}}},{"node":{"fields":{"slug":"/Multiports-and-Banks-of-Reactors","title":"Multiports And Banks Of Reactors"}}},{"node":{"fields":{"slug":"/Overview","title":"Overview"}}},{"node":{"fields":{"slug":"/Protobufs","title":"Protobufs"}}},{"node":{"fields":{"slug":"/Publications-and-Presentations","title":"Publications And Presentations"}}},{"node":{"fields":{"slug":"/Regression-Tests","title":"Regression Tests"}}},{"node":{"fields":{"slug":"/Related-Work","title":"Related Work"}}},{"node":{"fields":{"slug":"/Results-of-Experiments-for-Rhythm","title":"Results Of Experiments For Rhythm"}}},{"node":{"fields":{"slug":"/Running-Benchmarks","title":"Running Benchmarks"}}},{"node":{"fields":{"slug":"/Running-Lingua-Franca-IDE-(Epoch)-with-Kotlin-based-Code-Generators-Enabled-(without-Eclipse-Environment)","title":"Running Lingua Franca IDE Epoch With Kotlin Based Code Generators Enabled Without Eclipse Environment"}}},{"node":{"fields":{"slug":"/Support-Matrix","title":"Support Matrix"}}},{"node":{"fields":{"slug":"/Tardiness","title":"Tardiness"}}},{"node":{"fields":{"slug":"/Target-Specification","title":"Target Specification"}}},{"node":{"fields":{"slug":"/Termination","title":"Termination"}}},{"node":{"fields":{"slug":"/Timing-Analysis","title":"Timing Analysis"}}},{"node":{"fields":{"slug":"/Tools","title":"Tools"}}},{"node":{"fields":{"slug":"/Troubleshooting","title":"Troubleshooting"}}},{"node":{"fields":{"slug":"/Using-Maven","title":"Using Maven"}}},{"node":{"fields":{"slug":"/Web-Based-Editor","title":"Web Based Editor"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Cpp","title":"Writing Reactors In Cpp"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Python","title":"Writing Reactors In Python"}}},{"node":{"fields":{"slug":"/","title":"Landing Page"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-TypeScript","title":"Writing Reactors In Type Script"}}}]}},"pageContext":{"id":"0b086bf2-7d15-5a45-b3a7-c7a27036c4c9"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}