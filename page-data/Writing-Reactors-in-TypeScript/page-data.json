{"componentChunkName":"component---src-templates-docs-js","path":"/Writing-Reactors-in-TypeScript","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Gitbook Boilerplate | Hasura","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"e59c68bb-ab7d-553d-801e-17cf8f0d1fe8","title":"Writing Reactors In Type Script","slug":"/Writing-Reactors-in-TypeScript"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In the TypeScript reactor target for Lingua Franca, reactions are written in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/\"\n  }, \"TypeScript\"), \" and the code generator generates a standalone TypeScript program that can be compiled to JavaScript and run on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://nodejs.org\"\n  }, \"Node.js\"), \".\"), mdx(\"p\", null, \"TypeScript reactors bring the strengths of TypeScript and Node.js to Lingua Franca programming. The TypeScript language and its associated tools enable static type checking for both reaction code and Lingua Franca elements like ports and actions. The Node.js JavaScript runtime provides an execution environment for asynchronous network applications. With Node.js comes Node Package Manager (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/\"\n  }, \"npm\"), \") and its large library of supporting modules. \"), mdx(\"p\", null, \"In terms of raw performance on CPU intensive operations, TypeScript reactors are about two orders of magnitude slower than C reactors. But excelling at CPU intensive operations isn't really the point of Node.js (or by extension TypeScript reactors). Node.js is about achieving high throughput on network applications by efficiently handling asynchronous I/O operations. Keep this in mind when choosing the right Lingua Franca target for your application.\"), mdx(\"h2\", null, \"Setup\"), mdx(\"p\", null, \"First, make sure Node.js is installed on your machine. You can \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://nodejs.org/en/download/\"\n  }, \"download Node.js here\"), \". The npm package manager comes along with Node. \"), mdx(\"p\", null, \"After installing Node, you may optionally install the TypeScript compiler.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"npm install -g typescript\\n\")), mdx(\"p\", null, \"TypeScript reactor projects are created with a local copy of the TypeScript compiler, but having the TypeScript compiler globally installed can be useful for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#debugging-type-errors\"\n  }, \"debugging type errors\"), \" and type checking on the command line. \"), mdx(\"h2\", null, \"A Minimal Example\"), mdx(\"p\", null, \"A \\\"hello world\\\" reactor for the TypeScript target looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nmain reactor Minimal {\\n    timer t;\\n    reaction(t) {=\\n        console.log(\\\"Hello World.\\\");\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The timer triggers at the start time of the execution causing the reaction to execute. This program can be found in a file called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/tree/master/xtext/org.icyphy.linguafranca/src/test/TS/Minimal.lf\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Minimal.lf\")), \" in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/tree/master/xtext/org.icyphy.linguafranca/src/test/TS\"\n  }, \"test directory\"), \", where you can also find quite a few more interesting examples. If you compile this using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"downloading-and-building#Command-Line-Tools\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"lfc\"), \" command-line compiler\"), \" or the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"downloading-and-building#Download-the-Integrated-Development-Environment\"\n  }, \"Eclipse-based IDE\"), \", a number of files and directories will be generated. You can run the compiled JavaScript program (from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minimal.lf\"), \"'s directory) with the command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$ node Minimal/dist/Minimal.js \\n\")), mdx(\"p\", null, \"The resulting output should look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Hello World.\\n\")), mdx(\"p\", null, \"Notice the compiler generates a project directory with the name of the .lf file. In this example the .lf file's name is \\\"Minimal\\\" but more generally, for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<LF_file_name>.lf\"), \" the command to run the program is: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$ node <LF_file_name>/dist/<LF_file_name>.js\\n\")), mdx(\"p\", null, \"Refer to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#implementation-details\"\n  }, \"TypeScript Project Structure\"), \" section to learn why the command looks like this.\"), mdx(\"h2\", null, \"The TypeScript Target Specification\"), mdx(\"p\", null, \"To have Lingua Franca generate TypeScript code, start your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file with the following target specification:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\n\")), mdx(\"p\", null, \"A TypeScript target specification may optionally include the following parameters:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fast [true|false]\"), \": Whether to execute as fast as possible ignoring real time. This defaults to false.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"keepalive [true|false]\"), \": Whether to continue executing even when there are no events on the event queue. The default is false. Usually, you will want to set this to true when you have \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"physical action\"), \"s.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"logging [ERROR|WARN|INFO|LOG|DEBUG]\"), \": The level of diagnostic messages about execution to print to the console. A message will print if this parameter is greater than or equal to the level of the message (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ERROR\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WARN\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"INFO\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"LOG\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DEBUG\"), \"). Internally this is handled by the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.npmjs.com/package/ulog\"\n  }, \"ulog module\"), \". \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"timeout <n> <units>\"), \": The amount of logical time to run before exiting. By default, the program will run forever or until forcibly stopped, with control-C, for example.\")), mdx(\"p\", null, \"For example, for the TypeScript target, in a source file named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \", you might specify:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript {\\n    fast: true,\\n    timeout: 10 secs,\\n    logging: INFO,\\n\\n};\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fast\"), \" option given above specifies to execute the file as fast as possible, ignoring timing delays.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"logging\"), \" option indicates diagnostic messages tagged as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ERROR\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WARN\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INFO\"), \" should print to the console. Messages tagged \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LOG\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DEBUG\"), \" will not print.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \" option specifies to stop after 10 seconds of logical time have elapsed.\"), mdx(\"h2\", null, \"Command-Line Arguments\"), mdx(\"p\", null, \"The generated JavaScript program understands the following command-line arguments, each of which has a short form (one character) and a long form:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-f, --fast [true | false]\"), \":  Specifies whether to wait for physical time to match logical time. The default is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"false\"), \". If this is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"true\"), \", then the program will execute as fast as possible, letting logical time advance faster than physical time.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-o, --timeout '<duration> <units>'\"), \": Stop execution when logical time has advanced by the specified \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"duration\"), \". The units can be any of nsec, usec, msec, sec, minute, hour, day, week, or the plurals of those. For the duration and units of a timeout argument to be parsed correctly as a single value, these should be specified in quotes with no leading or trailing space (eg '5 sec').\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-k, --keepalive [true | false]\"), \": Specifies whether to stop execution if there are no events to process. This defaults to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"false\"), \", meaning that the program will stop executing when there are no more events on the event queue. If you set this to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"true\"), \", then the program will keep executing until either the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"timeout\"), \" logical time is reached or the program is externally killed. If you have \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"physical action\"), \"s, it usually makes sense to set this to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"true\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-l, --logging [ERROR | WARN | INFO | LOG | DEBUG]\"), \": The level of logging messages from the reactor-ts runtime to to print to the console. Messages tagged with a given type (error, warn, etc.) will print if this argument is greater than or equal to the level of the message (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ERROR\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WARN\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"INFO\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"LOG\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DEBUG\"), \").\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-h, --help\"), \": Print this usage guide. The program will not execute if this flag is present. \")), mdx(\"p\", null, \"If provided, a command line argument will override whatever value the corresponding target property had specified in the source .lf file. \"), mdx(\"p\", null, \"Command line options are parsed by the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/75lb/command-line-args\"\n  }, \"command-line-arguments\"), \" module with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/75lb/command-line-args/wiki/Notation-rules\"\n  }, \"these rules\"), \". For example \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$ node <LF_file_name>/dist/<LF_file_name>.js -f false --keepalive=true -o '4 sec' -l INFO\\n\")), mdx(\"p\", null, \"is a valid setting.\"), mdx(\"p\", null, \"Any errors in command-line arguments result in printing the above information. The program will not execute if there is a parsing error for command-line arguments.\"), mdx(\"h3\", null, \"Custom Command-Line Arguments\"), mdx(\"p\", null, \"User-defined command-line arguments may be created by giving the main reactor \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#using-parameters\"\n  }, \"parameters\"), \". Assigning the main reactor a parameter of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boolean\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time\"), \" will add an argument with corresponding name and type to the generated program's command-line-interface. Custom arguments will also appear in the generated program's usage guide (from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--help\"), \" option). If the generated program is executed with a value specified for a custom command-line argument, that value will override the default value for the corresponding parameter. Arguments typed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boolean\"), \" are parsed in the expected way, but \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time\"), \" arguments must be specified on the command line like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--timeout\"), \" property as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'<duration> <units>'\"), \" (in quotes).\"), mdx(\"p\", null, \"Note: Custom arguments may not have the same names as standard arguments like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keepalive\"), \".\"), mdx(\"p\", null, \"For example this reactor has a custom command line argument named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"customArg\"), \" of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \" and default value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nmain reactor clArg(customArg:number(2)) {\\n    reaction (startup) {=\\n        console.log(customArg);\\n    =}\\n}\\n\")), mdx(\"p\", null, \"If this reactor is compiled from the file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"simpleCLArgs.lf\"), \", executing\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"node simpleCLArgs/dist/simpleCLArgs.js\\n\")), mdx(\"p\", null, \"outputs the default value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \". But running\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"node simpleCLArgs/dist/simpleCLArgs.js --customArg=42\\n\")), mdx(\"p\", null, \"outputs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42\"), \". Additionally, we can view documentation for the custom command line argument with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--help\"), \" command.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"node simpleCLArgs/dist/simpleCLArgs.js -h\\n\")), mdx(\"p\", null, \"The program will generate the standard usage guide, but also\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"--customArg '<duration> <units>'                    Custom argument. Refer to           \\n                                                      <path>/simpleCLArgs.lf \\n                                                      for documentation.\\n\")), mdx(\"h3\", null, \"Additional types for Custom Command-Line Arguments\"), mdx(\"p\", null, \"Main reactor parameters that are not typed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"boolean\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time\"), \" will not create custom command-line arguments. However, that doesn't mean it is impossible to obtain other types from the command line, just use a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" and specify how the parsing is done yourself. See below for an example of a reactor that parses a custom command-line argument of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" into a state variable of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array<number>\"), \" using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSON.parse\"), \" and a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards\"\n  }, \"user-defined type guard\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nmain reactor customType(arrayArg:string(\\\"\\\")) {\\n    preamble {=\\n        function isArrayOfNumbers(x: any): x is Array<number> {\\n            for (let item of x) {\\n                if (typeof item !== \\\"number\\\") {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    =}\\n    state foo:{=Array<number>=}({=[]=});\\n    reaction (startup) {=\\n        let parsedArgument = JSON.parse(customType);\\n        if (isArrayOfNumbers(parsedArgument)) {\\n            foo = parsedArgument;\\n            }\\n        else {\\n            throw new Error(\\\"Custom command line argument is not an array of numbers.\\\");\\n        }\\n        console.log(foo);\\n    =}\\n}\\n\")), mdx(\"h2\", null, \"Imports\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"Language-Specification#import-statement\"\n  }, \"import statement\"), \" can be used to share reactor definitions across several applications. Suppose for example that we modify the above \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minimal.lf\"), \" program as follows and store this in a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HelloWorld.lf\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nreactor HelloWorldInside {\\n    timer t;\\n    reaction(t) {=\\n        console.log(\\\"Hello World.\\\");\\n    =}\\n}\\nmain reactor HelloWorld {\\n    a = new HelloWorldInside();\\n}\\n\")), mdx(\"p\", null, \"This can be compiled and run, and its behavior will be identical to the version above.\\nBut now, this can be imported into another reactor definition as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nimport HelloWorld.lf;\\nmain reactor TwoHelloWorlds {\\n    a = new HelloWorldInside();\\n    b = new HelloWorldInside();\\n}\\n\")), mdx(\"p\", null, \"This will create two instances of the HelloWorld reactor, and when executed, will print \\\"Hello World\\\" twice.\"), mdx(\"p\", null, \"A more interesting illustration of imports can be found in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Import.lf\"), \" test case in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/tree/master/xtext/org.icyphy.linguafranca/src/test/TS\"\n  }, \"test directory\"), \".\"), mdx(\"h2\", null, \"Preamble\"), mdx(\"p\", null, \"Reactions may contain arbitrary TypeScript code, but often it is convenient for that code to invoke node modules or to share function/type/class definitions. For these purposes, a reactor may include a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"preamble\"), \" section. For example, the following reactor uses Node's built-in path module to extract the base name from a path:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nmain reactor Preamble {\\n    preamble {=\\n        import * as path from 'path';\\n    =}\\n    reaction (startup) {=\\n        var filename = path.basename('/Users/Refsnes/demo_path.js');\\n        console.log(filename);\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This will print:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"demo_path.js\\n\")), mdx(\"p\", null, \"By putting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import\"), \" in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"preamble\"), \", the library becomes available in all reactions of this reactor. Oddly, it also becomes available in all subsequently defined reactors in the same file. It's a bit more complicated to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#using-node-modules\"\n  }, \"set up node.js modules from npm\"), \" that aren't built-in, but the reaction code to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import\"), \" them is the same as what you see here.\"), mdx(\"p\", null, \"You can also use the preamble to define functions that are shared across reactions and reactors:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor Preamble {\\n    preamble {=\\n        function add42( i:number) {\\n            return i + 42;\\n        }\\n    =}\\n    timer t;\\n    reaction(t) {=\\n        let s = \\\"42\\\";\\n        let radix = 10;\\n        let i = parseInt(s, radix);\\n        console.log(\\\"Converted string \\\" + s + \\\" to number \\\" + i);\\n        console.log(\\\"42 plus 42 is \\\" + add42(42));\\n    =}\\n}\\n\")), mdx(\"p\", null, \"Not surprisingly, this will print:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Converted string 42 to number 42\\n42 plus 42 is 84\\n\")), mdx(\"h3\", null, \"Using Node Modules\"), mdx(\"p\", null, \"Installing Node.js modules for TypeScript reactors with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm\"), \" is essentially the same as installing modules for an ordinary Node.js program. First, write a Lingua Franca program (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \") and compile it. It may not type check if if you're \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#preamble\"\n  }, \"importing modules in the preamble\"), \" and you haven't installed the modules yet, but compiling your program will cause the TypeScript code generator to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#implementation-details\"\n  }, \"produce a project\"), \" for your program. There should now be a package.json file in the same directory as your .lf file. Open a terminal and navigate to that directory. You can use the standard \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.npmjs.com/cli/install\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"npm install\")), \" command to install modules for your TypeScript reactors. \"), mdx(\"p\", null, \"The important takeaway here is with the package.json file and the compiled JavaScript in the Foo/dist/ directory, you have a standard Node.js program that executes as such. You can modify and debug it just as you would a Node.js program.\"), mdx(\"h2\", null, \"Reactions\"), mdx(\"p\", null, \"Recall that a reaction is defined within a reactor using the following syntax:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reaction\"), \"(\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"triggers\"), \") \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"uses\"), \" -> \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"effects\"), \" {=\", mdx(\"br\", null), \"\\n\", \"\\xA0\", \"\\xA0\", \" ... target language code ... \", mdx(\"br\", null), \"\\n=}\")), mdx(\"p\", null, \"In this section, we explain how \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"triggers\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"uses\"), \", and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"effects\"), \" variables work in the TypeScript target.\"), mdx(\"h3\", null, \"Types\"), mdx(\"p\", null, \"In Lingua Franca, reactor elements like inputs, outputs, actions, parameters, and state are typed using target language types. For the TypeScript target, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/basic-types.html\"\n  }, \"TypeScript types\"), \" are generally acceptable with two notable exceptions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Custom types (and classes) must be defined in the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#preamble\"\n  }, \"preamble\"), \" before they may be used.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"undefined\"), \" is not a valid type for an input, output, or action. This is because \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"undefined\"), \" is used to designate the absence of an input, output, or action during a reaction.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"To benefit from type checking, you should declare types for your reactor elements.\"), \" If a type isn't declared for a state variable, it is assigned the type \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"unknown\")), \". If a type isn't declared for an input, output, or action, it is assigned the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts\"\n  }, \"reactor-ts\"), \" type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Present\"), \" which is defined as\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"export type Present = (number | string | boolean | symbol | object | null);\\n\")), mdx(\"h3\", null, \"Inputs and Outputs\"), mdx(\"p\", null, \"In the body of a reaction in the TypeScript target, inputs are simply referred to by name. An input of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" is  available within the body of a reaction as a local variable of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t | undefined\"), \". To determine whether an input is present, test the value of the input against \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" input is not present. \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WARNING\"), \" Be sure to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"===\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!==\"), \" operator and not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"==\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!=\"), \" to test against \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". In JavaScript/TypeScript the comparison \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined == null\"), \" yields the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \". It may also be tempting to rely upon the falsy evaluation of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" within an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if\"), \" statement, but this may introduce bugs. For example a reaction that tests the presence of input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if (x) { ... }\"), \" will not correctly identify potentially valid present values such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"\\\"\"), \".\"), mdx(\"p\", null, \"For example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Determinism.lf\"), \" test case in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/tree/master/xtext/org.icyphy.linguafranca/src/test/TS\"\n  }, \"test directory\"), \" includes the following reactor:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Destination {\\n    input x:number;\\n    input y:number;\\n    reaction(x, y) {=\\n        let sum = 0;\\n        if (x !== undefined) {\\n            sum += x;\\n        }\\n        if (y !== undefined) {\\n            sum += y;\\n        }\\n        console.log(\\\"Received \\\" + sum);\\n        if (sum != 2) {\\n            console.log(\\\"FAILURE: Expected 2.\\\");\\n            util.failure();\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The reaction refers to the inputs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \" by name and tests for their presence by testing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \" against \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \".  If a reaction is triggered by just one input, then normally it is not necessary to test for its presence. It will always be present. However TypeScript's type system is not smart enough to know such an input will never have type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" if there's no test against \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" within the reaction. An explicit type annotation (for example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x = x as t;\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" is the type of the input) may be necessary to avoid type errors from the compiler. In the above example, there are two triggers, so the reaction has no assurance that both will be present.\"), mdx(\"p\", null, \"Inputs declared in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"uses\"), \" part of the reaction do not trigger the reaction. Consider this modification of the above reaction:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reaction(x) y {=\\n    let sum = x as number;\\n    if (y !== undefined) {\\n        sum += y;\\n    }\\n    console.log(\\\"Received \\\" + sum + \\\".\\\");\\n=}\\n\")), mdx(\"p\", null, \"It is no longer necessary to test for the presence of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" because that is the only trigger. The input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \", however, may or may not be present at the logical time that this reaction is triggered. Hence, the code must test for its presence.\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"effects\"), \" portion of the reaction specification can include outputs and actions. Actions will be described below. Like inputs, an output of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" is available within the body of a reaction as a local variable of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t | undefined\"), \". The local variable for each output is initialized to the output's current value. Outputs are set by assigning a (non-\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \") value to its local variable (no changes will be made to an output if it has the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" at the end of a reaction). Whatever value an output's local variable has at the end of the reaction will be set to that output. If an output's local variable has the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" at the end of the reaction, that output will not be set and connected downstream inputs will be absent. For example, we can further modify the above example as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"output z:number;\\nreaction(x) y -> z {=\\n    let sum = x as number;\\n    if (y !== undefined) {\\n        sum += y;\\n    }\\n    z = sum;\\n=}\\n\")), mdx(\"p\", null, \"If an output gets set more than once at any logical time, downstream reactors will see only the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"final\"), \" value that is set. Since the order in which reactions of a reactor are invoked at a logical time is deterministic, and whether inputs are present depends only on their timestamps, the final value set for an output will also be deterministic.\"), mdx(\"p\", null, \"An output may even be set in different reactions of the same reactor at the same logical time. In this case, one reaction may wish to test whether the previously invoked reaction has set the output. It can do that using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!== undefined\"), \" test for that output. For example, the following reactor will always produce the output 42:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor TestForPreviousOutput {\\n    output out:number;\\n    reaction(startup) -> out {=\\n        if (Math.random() > 0.5) {\\n            out = 21;\\n        }\\n    =}\\n    reaction(startup) -> out {=\\n        let previous_output = out;\\n        if (previous_output) {\\n            out = 2 * previous_output;\\n        } else {\\n            out = 42;\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The first reaction may or may not set the output to 21. The second reaction doubles the output if it has been previously produced and otherwise produces 42. \"), mdx(\"h3\", null, \"Using State Variables\"), mdx(\"p\", null, \"A reactor may declare state variables, which become properties of each instance of the reactor. For example, the following reactor will produce the output sequence 0, 1, 2, 3, ... :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Count {\\n    state count:number(0);\\n    output y:number;\\n    timer t(0, 100 msec);\\n    reaction(t) -> y {=\\n        count++;\\n        y = count;\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The declaration on the second line gives the variable the name \\\"count\\\", declares its type to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \", and initializes its value to 0.  The type and initial value can be enclosed in the Typescript-code delimitters \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{= ... =}\"), \" if they are not simple identifiers, but in this case, that is not necessary.\"), mdx(\"p\", null, \"In the body of the reaction, the reactor's state variable is referenced by way of a local variable of the same name. The local variable will contain the current value of the state at the beginning of the reaction. The final value of the local variable will be used to update the state at the end of the reaction.\"), mdx(\"p\", null, \"It may be tempting to declare state variables in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"preamble\"), \", as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor FlawedCount {\\n    preamble {=\\n        let count = 0;\\n    =}\\n    output y:number;\\n    timer t(0, 100 msec);\\n    reaction(t) -> y {=\\n        count++;\\n        y = count;\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This will produce a sequence of integers, but if there is more than one instance of the reactor, those instances will share the same variable count. Hence, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"don't do this\"), \"! Sharing variables across instances of reactors violates a basic principle, which is that reactors communicate only by sending messages to one another. Sharing variables will make your program nondeterministic. If you have multiple instances of the above FlawedCount reactor, the outputs produced by each instance will not be predictable, and in an asynchronous implementation, will also not be repeatable.\"), mdx(\"p\", null, \"A state variable may be a time value, declared as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    state time_value:time(100 msec);\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time_value\"), \" variable will be of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \", which is an object used to represent a time in the TypeScript Target. Refer to the section on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#timed-behavior\"\n  }, \"timed behavior\"), \" for more information.\"), mdx(\"p\", null, \"A state variable can have an array or object value. For example, the following reactor computes the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"moving average\"), \" of the last four inputs each time it receives an input:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor MovingAverage {\\n    state delay_line:{=Array<number>=}({= [0.0, 0.0, 0.0] =});\\n    state index:number(0);\\n    input x:number;\\n    output out:number;\\n    reaction(x) -> out {=\\n        x = x as number;\\n        // Calculate the output.\\n        let sum = x;\\n        for (let i = 0; i < 3; i++) {\\n            sum += delay_line[i];\\n        }\\n        out = sum/4.0;\\n\\n        // Insert the input in the delay line.\\n        delay_line[index] = x;\\n\\n        // Update the index for the next input.\\n        index++;\\n        if (index >= 3) {\\n            index = 0;\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The second line declares that the type of the state variable is an array of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \"s with the initial value of the array being a three-element array filled with zeros.\"), mdx(\"p\", null, \"States whose type are objects can similarly be initialized. Declarations can take an object literal as the initial value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"state myLiteral:{= {foo: number, bar: string} =}({= {foo: 42, bar: \\\"baz\\\"} =});\\n\")), mdx(\"p\", null, \"or use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"state mySet:{=Set<number>=}({= new Set<number>() =});\\n\")), mdx(\"h3\", null, \"Using Parameters\"), mdx(\"p\", null, \"Reactor parameters are also referenced in the TypeScript code as local variables. The example below modifies the above \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Count\"), \" reactor so that its stride is a parameter:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nreactor Count(stride:number(1)) {\\n    state count:number(0);\\n    output y:number;\\n    timer t(0, 100 msec);\\n    reaction(t) -> y {=\\n        y = count;\\n        count += stride;\\n    =}\\n}\\nreactor Display {\\n    input x:number;\\n    reaction(x) {=\\n        console.log(\\\"Received: \\\" + x + \\\".\\\");\\n    =}\\n}\\nmain reactor Stride {\\n    c = new Count(stride = 2);\\n    d = new Display();\\n    c.y -> d.x;\\n}\\n\")), mdx(\"p\", null, \"The second line defines the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stride\"), \" parameter, gives its type, and gives its initial value. As with state variables, the type and initial value can be enclosed in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{= ... =}\"), \" if necessary. The parameter is referenced in the reaction  by referring to the local variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stride\"), \".\"), mdx(\"p\", null, \"When the reactor is instantiated, the default parameter value can be overridden. This is done in the above example near the bottom with the line:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    c = new Count(stride = 2);\\n\")), mdx(\"p\", null, \"If there is more than one parameter, use a comma separated list of assignments.\"), mdx(\"p\", null, \"Parameters in Lingua Franca are immutable. To encourage correct usage, parameter variables within a reaction are  local \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" variables. If you feel tempted to use a mutable parameter, instead try using the parameter to initialize state and modify the state variable instead. This is illustrated below by a further modification to the Stride example where it takes an initial \\\"start\\\" value for count as a second parameter: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nreactor Count(stride:number(1), start:number(5)) {\\n    state count:number(start);\\n    output y:number;\\n    timer t(0, 100 msec);\\n    reaction(t) -> y {=\\n        y = count;\\n        count += stride;\\n    =}\\n}\\nreactor Display {\\n    input x:number;\\n    reaction(x) {=\\n        console.log(\\\"Received: \\\" + x + \\\".\\\");\\n    =}\\n}\\nmain reactor Stride {\\n    c = new Count(stride = 2, start = 10);\\n    d = new Display();\\n    c.y -> d.x;\\n}\\n\")), mdx(\"p\", null, \"Parameters can have array or object values. Here is an example that outputs the elements of an array as a sequence of individual messages:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Source(sequence:{=Array<number>=}({= [0, 1, 2] =})) {\\n    output out:number;\\n    state count:number(0);\\n    logical action next;\\n    reaction(startup, next) -> out, next {=\\n        out = sequence[count];\\n        count++;\\n        if (count < sequence.length) {\\n            actions.next.schedule(0, null);\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"logical action\"), \" named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule\"), \" function are explained below in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#Scheduling-Delayed-Reactions\"\n  }, \"Scheduling Delayed Reactions\"), \", but here they are used simply to repeat the reaction until all elements of the array have been sent.\"), mdx(\"p\", null, \"Above, the parameter default value is an array with three elements, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0, 1, 2]\"), \". The syntax for giving this default value is a TypeScript array literal. Since this is TypeScript syntax, not Lingua Franca syntax, the initial value needs to be surrounded with the target code delimiters, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{= ... =}\"), \". The default value can be overridden when instantiating the reactor using a similar syntax:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"s = new Source(sequence={= [1, 2, 3, 4] =});\\n\")), mdx(\"p\", null, \"Both default and overridden values for parameters can also be created with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \" keyword:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Source(sequence:{=Array<number>=}({= new Array<number>() =})) {\\n\")), mdx(\"p\", null, \"and\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"s = new Source(sequence={= new Array<number() =});\\n\")), mdx(\"h3\", null, \"Sending and Receiving Custom Types\"), mdx(\"p\", null, \"You can define your own datatypes in TypeScript and send and receive those. Consider the following example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor CustomType {\\n    preamble {=\\n        type custom = string | null;\\n    =}\\n    output out:custom;\\n    reaction(startup) -> out {=\\n        out = null;\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"preamble\"), \" code defines a custom union type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \". \"), mdx(\"h2\", null, \"Timed Behavior\"), mdx(\"p\", null, \"See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#summary-of-time-functions\"\n  }, \"Summary of Time Functions\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#utility-function-reference\"\n  }, \"Utility Function Reference\"), \" for a quick API reference.\"), mdx(\"p\", null, \"Timers are specified exactly as in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"Language-Specification#timer-declaration\"\n  }, \"Lingua Franca language specification\"), \". When working with time in the TypeScript code body of a reaction, however, you will need to know a bit about its internal representation.\"), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \" is an class defined in the TypeScript target library file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time.ts\"), \" to represent a time instant or interval. For your convenience \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \" and other classes from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time.ts\"), \" library mentioned in these instructions are automatically imported into scope of your reactions. An instant is the number of nanoseconds that have elapsed since January 1, 1970. An interval is the difference between two instants. When an LF program starts executing, logical time is (normally) set to the instant provided by the operating system. (On some embedded platforms without real-time clocks, it will be set instead to zero.)\"), mdx(\"p\", null, \"Internally a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \" uses two numbers to represent the time. To prevent overflow (which would occur for time intervals spanning more than 0.29 years if a single JavaScript number, which has 2^53 bits of precision, were to be used), we use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"two\"), \" numbers to store a time value. The first number denotes the number of whole seconds in the interval or instant; the second number denotes the remaining number of nanoseconds in the interval or instant. The first number represents the number of seconds, the second number represents the number of nanoseconds. These fields are not accessible to the programmer, instead \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \"s may be manipulated by an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#summary-of-time-functions\"\n  }, \"API\"), \" with functions for addition, subtraction, and comparison.\"), mdx(\"p\", null, \"A reaction can examine the current logical time (which is constant during the execution of the reaction). For example, consider:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nmain reactor GetTime {\\n    timer t(0, 1 sec);\\n    reaction(t) {=\\n        let logical:TimeValue = util.getCurrentLogicalTime()\\n        console.log(\\\"Logical time is \\\" + logical + \\\".\\\");\\n    =}\\n}\\n\")), mdx(\"p\", null, \"When executed, you will get something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Logical time is (1584666585 secs; 805146880 nsecs).\\nLogical time is (1584666586 secs; 805146880 nsecs).\\nLogical time is (1584666587 secs; 805146880 nsecs).\\n...\\n\")), mdx(\"p\", null, \"Subsequent values of logical time are printed out in their raw form, of seconds and nanoseconds. If you look closely, you will see that each number is one second larger than the previous number.\"), mdx(\"p\", null, \"You can also obtain the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"elapsed\"), \" logical time since the start of execution, rather than exact logical time:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor GetTime {\\n    timer t(0, 1 sec);\\n    reaction(t) {=\\n        let logical:TimeValue = util.getElapsedLogicalTime()\\n        console.log(\\\"Logical time is \\\" + logical + \\\".\\\");\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This will produce:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Logical time is (0 secs; 0 nsecs).\\nLogical time is (1 secs; 0 nsecs).\\nLogical time is (2 secs; 0 nsecs).\\n...\\n\")), mdx(\"p\", null, \"You can get physical time, which comes from your platform's real-time clock:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor GetTime {\\n    timer t(0, 1 sec);\\n    reaction(t) {=\\n        let physical:TimeValue = util.getCurrentPhysicalTime()\\n        console.log(\\\"Physical time is \\\" + physical + \\\".\\\");\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This will produce something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Physical time is (1584666801 secs; 644171008 nsecs).\\nPhysical time is (1584666802 secs; 642269952 nsecs).\\nPhysical time is (1584666803 secs; 642278912 nsecs).\\n...\\n\")), mdx(\"p\", null, \"Notice that these numbers are increasing by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"roughly\"), \" one second each time.\"), mdx(\"p\", null, \"You can also get \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"elapsed\"), \" physical time from the start of execution:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor GetTime {\\n    timer t(0, 1 sec);\\n    reaction(t) {=\\n        let physical:TimeValue = util.getElapsedPhysicalTime()\\n        console.log(\\\"Physical time is \\\" + physical + \\\".\\\");\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This will produce something like: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Physical time is (0 secs; 2260992 nsecs).\\nPhysical time is (1 secs; 166912 nsecs).\\nPhysical time is (2 secs; 136960 nsecs).\\n...\\n\")), mdx(\"p\", null, \"You can create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \" yourself with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnitBasedTimeValue\"), \" class. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnitBasedTimeValue\"), \" is a subclass of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \" and can be used wherever you could also use a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \" directly obtained from one of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util\"), \" functions. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnitBasedTimeValue\"), \" is constructed with a whole number and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeUnit\"), \". A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeUnit\"), \" is an enum from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time.ts\"), \" library with convenient labels for common time units. These are nsec, usec, msec, sec (or secs), minute (or minutes), hour (or hours), day (or days), and week (or weeks).\"), mdx(\"p\", null, \"This reactor has an example of a UnitBasedTimeValue.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"main reactor GetTime {\\n    timer t(0, 1 sec);\\n    reaction(t) {=\\n        let myTimeValue:TimeValue = new UnitBasedTimeValue(200, TimeUnit.msec);\\n        let logical:TimeValue = util.getCurrentLogicalTime()\\n        console.log(\\\"My custom time value is \\\" + myTimeValue + \\\".\\\");\\n    =}\\n\")), mdx(\"p\", null, \"This will produce:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"My custom time value is 200 msec.\\nMy custom time value is 200 msec.\\nMy custom time value is 200 msec.\\n...\\n\")), mdx(\"h3\", null, \"Tags\"), mdx(\"p\", null, \"The TypeScript target provides a utility to get the current \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag\"), \" of a reaction. Recall that time in Lingua Franca is superdense and each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue \"), \"is paired with an integer \\\"microstep\\\" index to track the number of iterations at a particular \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \". A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag\"), \" is this combination of a TimeValue and a \\\"microstep\\\". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time.ts\"), \" library provides functions for adding, subtracting, and comparing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag\"), \"s.\"), mdx(\"p\", null, \"You can get the current \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag\"), \" in your reactions. This example illustrates tags with a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#zero-delay-actions\"\n  }, \"Zero-Delay Action\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nmain reactor GetTime {\\n    timer t(0, 1 sec);\\n    logical action a;\\n    reaction(t) -> a {=\\n        let superdense:Tag = util.getCurrentTag();\\n        console.log(\\\"First iteration - the tag is: \\\" + superdense + \\\".\\\");\\n        actions.a.schedule(0, null);\\n    =}\\n    reaction(a) {=\\n        let superdense:Tag = util.getCurrentTag();\\n        let timePart:TimeValue = superdense.time;\\n        let microstepPart:number = superdense.microstep;\\n        console.log(\\\"Second iteration - the time part of the tag is:  \\\" + timePart + \\\".\\\");\\n        console.log(\\\"Second iteration - the microstep part of the tag is:  \\\" + microstepPart + \\\".\\\");\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This will produce:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"First iteration - the tag is: ((1584669987 secs; 740464896 nsecs), 0).\\nSecond iteration - the time part of the tag is:  (1584669987 secs; 740464896 nsecs).\\nSecond iteration - the microstep part of the tag is:  1.\\nFirst iteration - the tag is: ((1584669988 secs; 740464896 nsecs), 0).\\nSecond iteration - the time part of the tag is:  (1584669988 secs; 740464896 nsecs).\\nSecond iteration - the microstep part of the tag is:  1.\\nFirst iteration - the tag is: ((1584669989 secs; 740464896 nsecs), 0).\\nSecond iteration - the time part of the tag is:  (1584669989 secs; 740464896 nsecs).\\nSecond iteration - the microstep part of the tag is:  1.\\n...\\n\")), mdx(\"p\", null, \"The first reaction prints the \\\"First iteration\\\" part of the output at microstep 0. The second reaction occurs one microstep later (explained in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#scheduling-delayed-reactions\"\n  }, \"Scheduling Delayed Reactions\"), \") and illustrates how to split a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag\"), \" into its constituent \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \" and microstep.\"), mdx(\"h3\", null, \"Scheduling Delayed Reactions\"), mdx(\"p\", null, \"Each action listed as an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"effect\"), \" for a reaction is available as a schedulable object in the reaction body via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"actions\"), \" object. The TypeScript target provides a special \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"actions\"), \" object with a property for each schedulable action. Schedulable actions (of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \") have the object method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schedule: (extraDelay: TimeValue | 0, value?: T) => void;\\n\")), mdx(\"p\", null, \"The first argument can either be the literal 0 (shorthand for 0 seconds) or a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnitBasedTimeValue\"), \". The second argument is the value for the action. Consider the following reactor:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nreactor Schedule {\\n    input x:number;\\n    logical action a;\\n    reaction(x) -> a {=\\n        actions.a.schedule(new UnitBasedTimeValue(200, TimeUnit.msec), null);\\n    =}\\n    reaction(a) {=\\n        let elapsedTime = util.getElapsedLogicalTime();\\n        console.log(\\\"Action triggered at logical time \\\" + elapsedTime + \\\" after start.\\\");\\n    =}\\n}\\n\")), mdx(\"p\", null, \"When this reactor receives an input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \", it calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \" on the action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \", so it will be triggered at the logical time offset (200 msec) with a null value. The action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" will be triggered at a logical time 200 milliseconds after the arrival of input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \". This will trigger the second reaction, which will use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.getElapsedLogicalTime()\"), \" function to determine how much logical time has elapsed since the start of execution. The third argument to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \" function is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"value\"), \", data that can be carried by the action, which is explained below. In the above example, there is no value.\"), mdx(\"h3\", null, \"Zero-Delay Actions\"), mdx(\"p\", null, \"If the specified delay in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \" call is zero, then the action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" will be triggered one \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"microstep\"), \" later in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"superdense time\"), \" (see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"language-specification#superdense-time\"\n  }, \"Superdense Time\"), \"). Hence, if the input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" arrives at metric logical time \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \", and you call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schedule()\"), \" as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"actions.a.schedule(0);\\n\")), mdx(\"p\", null, \"then when a reaction to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" is triggered, the input \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" will be absent (it was present at the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"previous\"), \" microstep). The reaction to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and the reaction to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" occur at the same metric time \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"t\"), \", but separated by one microstep, so these two reactions are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" logically simultaneous. These reactions execute with different \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#tags\"\n  }, \"Tags\"), \".\"), mdx(\"h2\", null, \"Actions With Values\"), mdx(\"p\", null, \"If an action is declared with a data type, then it can carry a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"value\"), \", a data value that becomes available to any reaction triggered by the action. The most common use of this is to implement a logical delay, where a value provided at an input is produced on an output with a larger logical timestamp. To accomplish that, it is much easier to use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"after\"), \" keyword on a connection between reactors. Nevertheless, in this section, we explain how to directly use actions with value. In fact, the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"after\"), \" keyword is implemented as described below.\"), mdx(\"p\", null, \"If you are familiar with other targets (like C) you may notice it is much easier to schedule actions with values in TypeScript because of TypeScript/JavaScript's garbage collected memory management. The following example implements a logical delay using an action with a value. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reactor Delay(delay:time(100 msec)) {\\n    input x:number;\\n    output out:number;\\n    logical action a:number;\\n    reaction(x) -> a {=\\n        actions.a.schedule(delay, x as number);\\n    =}\\n    reaction(a) -> out {=\\n        if (a !== null){\\n            out = a as number\\n        }\\n    =}\\n}\\n\")), mdx(\"p\", null, \"The action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" is specified with a type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \". The first reaction declares \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" as its effect. This declaration makes it possible for the reaction to schedule a future triggering of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \". It's necessary to explicitly annotate the type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" as a number in the schedule function because TypeScript doesn't know the only trigger of a reaction must be present in that reaction.\"), mdx(\"p\", null, \"The second reaction declares that it is triggered by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and has effect \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"out\"), \". When a reaction triggers or uses an action the value of that action is made available within the reaction as a local variable with the name of the action. This variable will take on the value of the action and it will have the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" if that action is absent because it was not scheduled for this reaction.\"), mdx(\"p\", null, \"The local variable cannot be used directly to schedule an action. As described above, an action \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" can only be scheduled in a reaction when it is 1) declared as an effect and 2) referenced through a property of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"actions\"), \" object.  The reason for this implementation is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"actions.a\"), \" refers to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"action\"), \", not its value, and it is possible to use both the action and the value in the same reaction. For example, the following reaction will produce a counting sequence after it is triggered the first time:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"reaction(a) -> out, a {=\\n    if (a !== null) {\\n        a = a as number;\\n        out = a;\\n        let newValue = a++;\\n        actions.a.schedule(delay, newValue);\\n    }\\n=}\\n\")), mdx(\"h2\", null, \"Stopping Execution\"), mdx(\"p\", null, \"A reaction may request that the execution stop by calling the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.requestShutdown()\"), \" which takes no arguments. Execution will not stop immediately when this function is called; all events with the current tag will finish processing and execution will continue for one more microstep to give shutdown triggers a chance to execute. After this additional step, execution will terminate.\"), mdx(\"h2\", null, \"Implementation Details\"), mdx(\"p\", null, \"When a TypeScript reactor is compiled, the generated code is placed inside a project directory. This is because there are two steps of compilation. First, the Lingua Franca compiler generates a TypeScript project from the TypeScript reactor code. Second, the Lingua Franca compiler runs a TypeScript compiler on the generated TypeScript project to produce executable JavaScript. This is illustrated below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Lingua Franca (.lf) ==> TypeScript (.ts) ==> JavaScript (.js)\\n\")), mdx(\"p\", null, \"Assuming the directory containing our Lingua Franca file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" is named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TS\"), \", the compiler will generate the following:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"TS/package.json\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"TS/node_modules\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"TS/Foo/tsconfig.json\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"TS/Foo/babel.config.js\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"TS/Foo/src/\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"TS/Foo/dist/\")), mdx(\"p\", null, \"Items 1, 3, and 4 are configuration files for the generated project. Item 2 is a node_modules directory with contents specified by item 1. Item 5 is the directory for generated TypeScript code. Item 6 is the directory for compiled JavaScript code. In addition to the generated code for your Lingua Franca program, items 5 and 6 include libraries from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts\"\n  }, \"reactor-ts\"), \" submodule.\"), mdx(\"p\", null, \"The Lingua Franca compiler automatically invokes other programs as it compiles a Lingua Franca (.lf) file to a Node.js executable JavaScript (.js) file. The files package.json, babel.config.js, and tsconfig.json are used to configure the behavior of those other programs. Whenever you compile a .lf file for the first time, the Lingua Franca compiler will copy default versions of these configuration files into the new project so the other programs can run. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The Lingua Franca compiler will only copy a default configuration file into a project if that file is not already present in the generated project.\"), \" This means you, the reactor programmer, may safely modify these configuration files to control the finer points of compilation. Beware, other generated files in the project's src and dist directories may be overwritten by the compiler.\"), mdx(\"h3\", null, \"package.json\"), mdx(\"p\", null, \"Node.js uses a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://nodejs.org/en/knowledge/getting-started/npm/what-is-the-file-package-json/\"\n  }, \"package.json\"), \" file to describe metadata relevant to a Node project. This includes a list of project dependencies (i.e. modules) used by the project. When the Lingua Franca compiler copies a default package.json file into a Lingua Franca project that doesn't already have a package.json, the compiler runs the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm install\"), \" to create a node_modules directory. The default package.json only lists dependencies for the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts\"\n  }, \"reactor-ts\"), \" submodule. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#using-node-modules\"\n  }, \"Follow these instructions\"), \" to modify package.json if you want to use other Node modules in your reactors.\"), mdx(\"h3\", null, \"tsconfig.json\"), mdx(\"p\", null, \"After generating a TypeScript program from a .lf file, the Lingua Franca compiler uses the TypeScript compiler \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsc\"), \" to run a type check. The behavior of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsc\"), \" is configured by the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\"\n  }, \"tsconfig.json\"), \" file. You probably won't need to modify tsconfig.json, but you can if you know what you're doing.\"), mdx(\"h3\", null, \"babel.config.js\"), mdx(\"p\", null, \"If the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsc\"), \" type check was successful, the Lingua Franca compiler uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"babel\"), \" to compile the generated TypeScript code into JavaScript. (This \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://iamturns.com/typescript-babel/\"\n  }, \"blog post\"), \" articulates the advantages of using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"babel\"), \" over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsc\"), \" to generate JavaScript.) There are many different flavors of JavaScript and the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://babeljs.io/docs/en/configuration\"\n  }, \"babel.config.js\"), \" file specifies exactly what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"babel\"), \" should generate. This is the file to edit if you want the Lingua Franca compiler to produce a different version of JavaScript as its final output.\"), mdx(\"h2\", null, \"Debugging Type Errors\"), mdx(\"p\", null, \"Let's take the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#a-minimal-example\"\n  }, \"minimal reactor example\"), \", and intentionally break it by adding a type error into the reaction.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nmain reactor ReactionTypeError {\\n    timer t;\\n    reaction(t) {=\\n        let foo:number = \\\"THIS IS NOT A NUMBER\\\";\\n        console.log(\\\"Hello World.\\\");\\n    =}\\n}\\n\")), mdx(\"p\", null, \"This reactor will not compile, and should you attempt to compile it you will get an output from the compiler which looks something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"--- Standard output from command:\\nsrc/ReactionTypeError.ts(23,25): error TS2322: Type '\\\"THIS IS NOT A NUMBER\\\"' is not assignable to type 'number'.\\n\\n--- End of standard output.\\n\")), mdx(\"p\", null, \"In particular the output\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"src/ReactionTypeError.ts(23,25): error TS2322: Type '\\\"THIS IS NOT A NUMBER\\\"' is not assignable to type 'number'.\\n\")), mdx(\"p\", null, \"identifies the problem: surprisingly, the string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"THIS IS NOT A NUMBER\\\"\"), \" is not a number. However the line information \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(23,25)\"), \" is a little confusing because it points to the location of the type error \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"in the generated\"), \" .ts file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactionTypeError/src/ReactionTypeError.ts\"), \" not in the original .lf file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactionTypeError.lf\"), \". The .ts files produced by the TypeScript code generator are quite readable if you are familiar with the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts\"\n  }, \"reactor-ts\"), \" submodule, but even if you aren't familiar it is not too difficult to track down the problem. Just open \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactionTypeError/src/ReactionTypeError.ts\"), \" in your favorite text editor (we recommend \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://code.visualstudio.com/docs/languages/typescript\"\n  }, \"Visual Studio\"), \" for its excellent TypeScript integration) and look at line 23.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"14        this.addReaction(\\n15            new Triggers(this.t),\\n16            new Args(this.t),\\n17            function (this, __t: Readable<Tag>) {\\n18                // =============== START react prologue\\n19                const util = this.util;\\n20                let t = __t.get();\\n21                // =============== END react prologue\\n22                try {\\n23                    let foo:number = \\\"THIS IS NOT A NUMBER\\\";\\n24                    console.log(\\\"Hello World.\\\");\\n25                } finally {\\n26                    // =============== START react epilogue\\n27                    \\n28                    // =============== END react epilogue\\n29                }\\n30            }\\n31        );\\n\")), mdx(\"p\", null, \"There (inside the try block) we can find the problematic reaction code. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Reaction code is copied verbatim into generated .ts files\"), \".\"), mdx(\"p\", null, \"It can be a bit harder to interpret type errors outside of reaction code, but most type error messages are still relatively clear. For example if you attempt to connect a reactor output to an incompatibly typed input like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"target TypeScript;\\nmain reactor ConnectionError {\\n    s = new Sender();\\n    r = new Receiver();\\n    s.foo -> r.bar;\\n}\\nreactor Sender {\\n    output foo:number;\\n}\\nreactor Receiver {\\n    input bar:string;\\n}\\n\")), mdx(\"p\", null, \"you should get an error like\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"--- Standard output from command:\\nsrc/InputTypeError.ts(36,23): error TS2345: Argument of type 'OutPort<number>' is not assignable to parameter of type 'Port<string>'.\\n  Types of property 'value' are incompatible.\\n    Type 'number | undefined' is not assignable to type 'string | undefined'.\\n      Type 'number' is not assignable to type 'string | undefined'.\\n\\n--- End of standard output.\\n\")), mdx(\"p\", null, \"The key message being \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Argument of type 'OutPort<number>' is not assignable to parameter of type 'Port<string>'\"), \".\"), mdx(\"p\", null, \"One last tip: if you attempt to reference a port, action, timer etc. named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" that isn't declared in the triggers, uses, or effects declaration of the reaction, you will get the error \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cannot find name 'foo'\"), \" in the reaction body.\"), mdx(\"h2\", null, \"Utility Function Reference\"), mdx(\"p\", null, \"These utility functions may be called within a TypeScript reaction:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.requestShutdown(): void\"), \" Ends execution after one microstep. See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#stopping-execution\"\n  }, \"Stopping Execution\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.getCurrentTag(): Tag\"), \" Gets the current (logical) tag. See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#tags\"\n  }, \"Tags\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.getCurrentLogicalTime(): TimeValue\"), \" Gets the current logical TimeValue. See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#timed-behavior\"\n  }, \"Time\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.getCurrentPhysicalTime(): TimeValue\"), \" Gets the current physical TimeValue. See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#timed-behavior\"\n  }, \"Time\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.getElapsedLogicalTime(): TimeValue\"), \" Gets the elapsed logical TimeValue from execution start. See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#timed-behavior\"\n  }, \"Time\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.getElapsedPhysicalTime(): TimeValue\"), \" Gets the elapsed physical TimeValue from execution start. See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#timed-behavior\"\n  }, \"Time\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.success(): void\"), \" Invokes the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts\"\n  }, \"reactor-ts\"), \" App's default success callback. FIXME: Currently doesn't do anything in Lingua Franca.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"util.failure(): void\"), \" Invokes the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts\"\n  }, \"reactor-ts\"), \" App's default failure callback. Throws an error.\"), mdx(\"h2\", null, \"Summary of Time Functions\"), mdx(\"p\", null, \"See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#timed-behavior\"\n  }, \"Time\"), \". These time functions are defined in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts/blob/master/src/core/time.ts\"\n  }, \"time.ts\"), \" library of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts\"\n  }, \"reactor-ts\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnitBasedTimeValue(value: number, unit:TimeUnit)\"), \" Constructor for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnitBasedTimeValue\"), \", a programmer-friendly subclass of TimeValue. Use a number and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeUnit\"), \" enum.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"enum TimeUnit {\\n    nsec,\\n    usec,\\n    msec,\\n    sec,\\n    secs,\\n    minute,\\n    minutes,\\n    hour,\\n    hours,\\n    day,\\n    days,\\n    week,\\n    weeks\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue.add(other: TimeValue): TimeValue\"), \" Adds \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"other\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue.subtract(other: TimeValue): TimeValue\"), \" Subtracts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"other\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \". A negative result is an error.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue.difference(other: TimeValue): TimeValue\"), \" Obtain absolute value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"other\"), \" minus \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue.isEqualTo(other: TimeValue): boolean\"), \" Returns true if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"other\"), \" represents the same TimeValue. Otherwise false.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue.isZero(): boolean\"), \" Returns true if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" represents a 0 TimeValue.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeValue.isEarlierThan(other: TimeValue): boolean\"), \" Returns true if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"other\"), \". Otherwise false.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag.isSmallerThan(other: Tag): boolean\"), \" Returns true if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" < \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"other\"), \". Otherwise false.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag.isSimultaneousWith(other: Tag): boolean\"), \" Returns true if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"other\"), \" represents the same Tag. Otherwise false.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag.getLaterTag(delay: TimeValue): Tag\"), \" Returns a tag with the time part of this TimeValue incremented by delay.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tag.getMicroStepLater(): Tag\"), \" Returns a tag with the microstep part of this TimeValue incremented by 1.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getTimeDifference(other: Tag): TimeValue\"), \" Returns a TimeValue  that represents the absolute (i.e., positive) time difference between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"other\"), \".\"), mdx(\"h2\", null, \"Building Reactor-ts Documentation\"), mdx(\"p\", null, \"FIXME: Host these docs somewhere.\"), mdx(\"p\", null, \"To build and view proper documentation for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time.ts\"), \" (and other reactor-ts libraries), install \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://typedoc.org/\"\n  }, \"typedoc\"), \" and run\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"typedoc --out docs src\\n\")), mdx(\"p\", null, \"from the root of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/reactor-ts\"\n  }, \"reactor-ts\"), \". You probably already have the reactor-ts submodule at \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"lingua-franca/xtext/org.icyphy.linguafranca/src/lib/TS/reactor-ts/\\n\")), mdx(\"p\", null, \"You should see an output like.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Using TypeScript 3.8.3 from /usr/local/lib/node_modules/typescript/lib\\nRendering [========================================] 100%\\n\\nDocumentation generated at /Users/<username>/git/lingua-franca/xtext/org.icyphy.linguafranca/src/lib/TS/reactor-ts/docs\\n\")), mdx(\"p\", null, \"Open that path in a browser with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/index.html\"), \" appended to the end like\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"/Users/<username>/git/lingua-franca/xtext/org.icyphy.linguafranca/src/lib/TS/reactor-ts/docs/index.html\\n\")), mdx(\"p\", null, \"to navigate the docs.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#setup","title":"Setup"},{"url":"#a-minimal-example","title":"A Minimal Example"},{"url":"#the-typescript-target-specification","title":"The TypeScript Target Specification"},{"url":"#command-line-arguments","title":"Command-Line Arguments","items":[{"url":"#custom-command-line-arguments","title":"Custom Command-Line Arguments"},{"url":"#additional-types-for-custom-command-line-arguments","title":"Additional types for Custom Command-Line Arguments"}]},{"url":"#imports","title":"Imports"},{"url":"#preamble","title":"Preamble","items":[{"url":"#using-node-modules","title":"Using Node Modules"}]},{"url":"#reactions","title":"Reactions","items":[{"url":"#types","title":"Types"},{"url":"#inputs-and-outputs","title":"Inputs and Outputs"},{"url":"#using-state-variables","title":"Using State Variables"},{"url":"#using-parameters","title":"Using Parameters"},{"url":"#sending-and-receiving-custom-types","title":"Sending and Receiving Custom Types"}]},{"url":"#timed-behavior","title":"Timed Behavior","items":[{"url":"#tags","title":"Tags"},{"url":"#scheduling-delayed-reactions","title":"Scheduling Delayed Reactions"},{"url":"#zero-delay-actions","title":"Zero-Delay Actions"}]},{"url":"#actions-with-values","title":"Actions With Values"},{"url":"#stopping-execution","title":"Stopping Execution"},{"url":"#implementation-details","title":"Implementation Details","items":[{"url":"#packagejson","title":"package.json"},{"url":"#tsconfigjson","title":"tsconfig.json"},{"url":"#babelconfigjs","title":"babel.config.js"}]},{"url":"#debugging-type-errors","title":"Debugging Type Errors"},{"url":"#utility-function-reference","title":"Utility Function Reference"},{"url":"#summary-of-time-functions","title":"Summary of Time Functions"},{"url":"#building-reactor-ts-documentation","title":"Building Reactor-ts Documentation"}]},"parent":{"relativePath":"Writing-Reactors-in-TypeScript.md"},"frontmatter":{"metaTitle":null,"metaDescription":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Benchmarks","title":"Benchmarks"}}},{"node":{"fields":{"slug":"/A-future-proof-package-and-import-system","title":"A Future Proof Package And Import System"}}},{"node":{"fields":{"slug":"/Clone-the-Repository","title":"Clone The Repository"}}},{"node":{"fields":{"slug":"/Containerized-Execution","title":"Containerized Execution"}}},{"node":{"fields":{"slug":"/Contributing","title":"Contributing"}}},{"node":{"fields":{"slug":"/Creating-and-Managing-Submodules","title":"Creating And Managing Submodules"}}},{"node":{"fields":{"slug":"/Developer-IntelliJ-Setup-(for-Kotlin)","title":"Developer Intelli J Setup For Kotlin"}}},{"node":{"fields":{"slug":"/Diagrams","title":"Diagrams"}}},{"node":{"fields":{"slug":"/Distributed-Execution","title":"Distributed Execution"}}},{"node":{"fields":{"slug":"/Generic-Types,-Interfaces,-and-Inheritance","title":"Generic Types Interfaces And Inheritance"}}},{"node":{"fields":{"slug":"/Downloading-and-Building","title":"Downloading And Building"}}},{"node":{"fields":{"slug":"/Home","title":"Home"}}},{"node":{"fields":{"slug":"/Import-System","title":"Import System"}}},{"node":{"fields":{"slug":"/Legacy-Eclipse-Instructions","title":"Legacy Eclipse Instructions"}}},{"node":{"fields":{"slug":"/Maven-Notes","title":"Maven Notes"}}},{"node":{"fields":{"slug":"/Modal-Models-RFC","title":"Modal Models RFC"}}},{"node":{"fields":{"slug":"/Multiports-and-Banks-of-Reactors","title":"Multiports And Banks Of Reactors"}}},{"node":{"fields":{"slug":"/Overview","title":"Overview"}}},{"node":{"fields":{"slug":"/Protobufs","title":"Protobufs"}}},{"node":{"fields":{"slug":"/Publications-and-Presentations","title":"Publications And Presentations"}}},{"node":{"fields":{"slug":"/Regression-Tests","title":"Regression Tests"}}},{"node":{"fields":{"slug":"/Related-Work","title":"Related Work"}}},{"node":{"fields":{"slug":"/Results-of-Experiments-for-Rhythm","title":"Results Of Experiments For Rhythm"}}},{"node":{"fields":{"slug":"/Running-Benchmarks","title":"Running Benchmarks"}}},{"node":{"fields":{"slug":"/Running-Lingua-Franca-IDE-(Epoch)-with-Kotlin-based-Code-Generators-Enabled-(without-Eclipse-Environment)","title":"Running Lingua Franca IDE Epoch With Kotlin Based Code Generators Enabled Without Eclipse Environment"}}},{"node":{"fields":{"slug":"/Support-Matrix","title":"Support Matrix"}}},{"node":{"fields":{"slug":"/Tardiness","title":"Tardiness"}}},{"node":{"fields":{"slug":"/Target-Specification","title":"Target Specification"}}},{"node":{"fields":{"slug":"/Termination","title":"Termination"}}},{"node":{"fields":{"slug":"/Timing-Analysis","title":"Timing Analysis"}}},{"node":{"fields":{"slug":"/Tools","title":"Tools"}}},{"node":{"fields":{"slug":"/Troubleshooting","title":"Troubleshooting"}}},{"node":{"fields":{"slug":"/Using-Maven","title":"Using Maven"}}},{"node":{"fields":{"slug":"/Web-Based-Editor","title":"Web Based Editor"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Cpp","title":"Writing Reactors In Cpp"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Python","title":"Writing Reactors In Python"}}},{"node":{"fields":{"slug":"/","title":"Landing Page"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-TypeScript","title":"Writing Reactors In Type Script"}}}]}},"pageContext":{"id":"e59c68bb-ab7d-553d-801e-17cf8f0d1fe8"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}