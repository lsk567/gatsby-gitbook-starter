{"componentChunkName":"component---src-templates-docs-js","path":"/A-future-proof-package-and-import-system","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Gitbook Boilerplate | Hasura","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"8965a35a-796e-5961-8628-01080b13f007","title":"A Future Proof Package And Import System","slug":"/A-future-proof-package-and-import-system"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is a collection of thoughts on the design of a reliable package and import system that is ready for future applications. At this stage, this page mostly represents my personal view (Christian Menard). I will also focus on the C++ target here as this is the target I know best. The C target is not a good example for these considerations as there is a fundamental design issue with the C target. Since the code generator places all code in a single generated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".c\"), \" file and does things like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#include reactor.c\"), \" to avoid the need for Makefiles, it circumvents many of the issues that come with imports that I will outline here. It simply ignores file scopes and namespaces altogether.\"), mdx(\"h1\", null, \"The status quo\"), mdx(\"p\", null, \"The current import system is lean and simple. Write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import Bar.lf\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" and every reactor defined in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.lf\"), \" will be visible in the file scope \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.lf\"), \" is looked up simply by scanning the directory \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" is placed in. This works well for the simple programs and tests we have right now, but does not scale. I identify the following problems:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"There is no notion of separate namespaces. Every reactor that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.lf\"), \" defines becomes visible in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \". If both files define a Reactor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \", there is a name clash and the import would be ill-formed. There should be a mechanism to distinguish the two definitions of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \", such as using fully qualified names: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.Foo\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.Foo\"), \".\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"There is no concept for importing files from a directory structure. It is unclear how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" could import \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"my/lib/Bar.lf\"), \".\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"There is no concept for packages or libraries that can be installed on the system. How could we import Reactors from a library that someone else provided?\"))), mdx(\"p\", null, \"These are the more obvious issues that we have talked about. However, there are more subtle ones that we haven't been discussed in depth (or at least not in the context of the import system design discussion). The open question is: What does importing a LF file actually mean? Obviously, an import should bring Reactors defined in another files into local scope. But what should happen with the other structures that are part of an LF file, namely target properties and preambles? That is not specified and our targets use a best practice approach. But this is far away from a good design that is scalable and future proof.\"), mdx(\"h2\", null, \"A quick dive into the C++ code generator\"), mdx(\"p\", null, \"Before I discuss the problems with preambles and target properties, I would like to give you a quick overview of how the C++ code generator works. Consider the following LF program consisting of two files \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.lf\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Bar.lf\\n\\nreactor Bar {\\n reaction(startup) {=\\n   // do something bar like\\n =}\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Foo.lf\\n\\nimport Bar.lf\\n\\nreactor Foo {\\n bar = new Bar();\\n reaction(startup) {=\\n   // do something foo like\\n =}\\n}\\n\")), mdx(\"p\", null, \"Now let us have a look on what the C++ code generator does. It will produce a file structure like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"CMakeLists.txt\\nmain.cc\\nBar/\\n  Bar.cc\\n  Bar.hh\\nFoo/\\n  Foo.cc\\n  Foo.hh\\n\")), mdx(\"p\", null, \"We can ignore \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CMakeLists.txt\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main.cc\"), \" for our discussion here. The former specifies how the whole program can be build and the latter contains the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main()\"), \" function and some code that is required to get the application up and running. For each processed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<file>.lf\"), \" file, the code generator creates a directory \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<file>\"), \". For each reactor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<reactor>\"), \" defined in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<file>.lf\"), \", it will create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<file>/<reactor>.cc\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<file>/<reactor>.hh\"), \". The header file declares a class representing the reactor like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Bar/Bar.hh\\n\\n# pragma once\\n\\n#include \\\"reactor-cpp/reactor-cpp.hh\\\"\\n\\nclass Bar : public reactor::Reacor {\\n private:\\n  // default actions\\n  reactor::StartupAction startup {\\\"startup\\\", this};\\n  reactor::ShutdownAction shutdown {\\\"shutdown\\\", this};\\n\\n public:\\n  /* ... */\\n\\n private:\\n  // reaction bodies \\n  r0_body();\\n};\\n\")), mdx(\"p\", null, \"The corresponding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar/Bar.cc\"), \" will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"#include \\\"Bar/Bar.hh\\\"\\n\\n/* ... */\\n\\nBar::r0_body() {\\n  // do something bar like\\n}\\n\")), mdx(\"p\", null, \"Similarly, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.hh\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.cc\"), \" will be generated. However, since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" imports \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.lf\"), \" and instantiated the reactor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \" it must be made visible. This is done by an include directive in the generated code like so:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Foo/Foo.hh\\n### \\n# pragma once\\n\\n#include \\\"reactor-cpp/reactor-cpp.hh\\\"\\n#include \\\"Bar/Bar.hh\\\"\\n\\nclass Foo : public reactor::Reacor {\\n private:\\n  // default actions\\n  reactor::StartupAction startup;\\n  reactor::ShutdownAction shutdown;\\n\\n  // reactor instances\\n  Bar bar;\\n public:\\n  /* ... */\\n\\n private:\\n  // reaction bodies \\n  r0_body();\\n};\\n\")), mdx(\"h2\", null, \"The problem with preambles\"), mdx(\"p\", null, \"The problems with preamble in the context of imports were already discussed in a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pulls\"\n  }, \"related issue\"), \", but I would like to summarize the problem here. While the examples above worked nicely even with imports, things get messy as soon as we introduce a preamble. Let's try this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Bar.lf\\n\\nreactor Bar {\\n preamble {=\\n   struct bar_t {\\n     int x;\\n     std::string y;\\n   };\\n\\n   bar_t bar_func {\\n     return bar_t(42, \\\"hello\\\")\\n   }\\n =}\\n output out:bar_t;\\n reaction(startup) -> out {=\\n   out.set(bar_fuc());\\n =}\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Foo.lf\\n\\nimport Bar.lf\\n\\nreactor Foo \\n bar = new Bar();\\n reaction(bar.out) {=\\n   auto& value = bar.out.get();\\n   std::cout << \\\"Received {\\\" << value->x << \\\", \\\" << value->y << \\\"}\\\\n\\\";\\n =}\\n}\\n\")), mdx(\"p\", null, \"This would be expected to print \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Received {32, hello}\"), \". However, before we can even compile this program, we need to talk about what should happen with the preamble during code generation and how the import affects it. So where should the preamble go? The first thing that comes to mind, is to embed it in the header file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.hh\"), \" something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Bar/Bar.hh\\n\\n# pragma once\\n\\n#include \\\"reactor-cpp/reactor-cpp.hh\\\"\\n\\n// preamble\\nstruct bar_t {\\n  int x;\\n  std::string y;\\n};\\n\\nbar_t bar_func {\\n  return bar_t(42, \\\"hello\\\")\\n}\\n\\nclass Bar : public reactor::Reacor {\\n /* ... */\\n};\\n\")), mdx(\"p\", null, \"If we embed the preamble like this and compile the program ,then the compiler is actually happy and processes all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*.cc\"), \" files without any complaints. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"But\"), \", there is a huge problem while linking the binary. The linker sees multiple definitions of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_func\"), \" and has no idea which one to use. Why is that? Well, the definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_func\"), \" is contained in a header file. This should never be done in C/C++! Since includes translate to a plain-text replacement by the preprocessor, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.cc\"), \" will contain the full definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_func\"), \". As \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.cc\"), \" imports \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.hh\"), \" which imports \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.hh\"), \", also Foo.cc will contain the full definition. And since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main.cc\"), \" also has to include \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.hh\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main.cc\"), \" will also contain the full definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_func\"), \". So we have multiple definitions of the same function and the linker rightfully reports this as an error.\"), mdx(\"p\", null, \"So what should we do? We could place the preamble in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.cc\"), \" instead. This ensures that only \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.cc\"), \" sees the definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_func\"), \". But then the compiler complains. Neither \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.hh\"), \" nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.hh\"), \" see type declaration of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_t\"), \". Note that there is a dependency of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" on the preamble in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.lf\"), \". The import system should somehow take care of this dependency! Also note that this has not appeared as a problem in C as the code generator places everything in the same compilation unit. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" will see the preamble of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \" as long as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" is generated before \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \".\"), mdx(\"p\", null, \"But how to solve it for C++ where the code is split in multiple compilation units (which really should be happening in C as well)? What we do at the moment is annotating the preamble with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"private\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public\"), \" keywords. This helps to split the preamble up and decide what to place in the header and what to place in the source file. For instance:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Bar.lf\\n\\nreactor Bar {\\n public preamble {=\\n   struct bar_t {\\n     int x;\\n     std::string y;\\n   };\\n =}\\n private preamble {=\\n   bar_t bar_func {\\n     return bar_t(42, \\\"hello\\\")\\n   }\\n =}\\n output out:bar_t;\\n reaction(startup) -> out {=\\n   out.set(bar_fuc());\\n =}\\n}\\n\")), mdx(\"p\", null, \"This makes the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_t\"), \" visible as part of the public interface of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \". Both the code generated for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \" and the code generated for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" will see the definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_t\"), \". This is realized by placing the public preamble in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.hh\"), \" The function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar_func\"), \" is part of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \"'s private interface. It is only visible with the reactor definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \" and is not propagated by an import. This is realized by simply placing the private preamble in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.cc\"), \". This makes the compiler finally happy and when get an executable program private and public preambles provide a mechanism to define what is propagated on an import and what is not. I think this is an important distinction even in languages other than C/C++ that do not have this weird separation of source and header file.\"), mdx(\"p\", null, \"I am sorry for this lengthy diversion into things that happened in the past where we actually want to talk about how things should work in the future. However, understanding this issue is important and when talking about other solutions we should not forget that it exists.\"), mdx(\"h2\", null, \"The problem with target properties\"), mdx(\"p\", null, \"It is also not well-defined what should happen with target properties when importing a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file. Apparently the common practice is simply ignoring the existence of other target declarations and only considering the target declaration of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" that contains the main reactor. I think this works reasonably well for our small programs. But it will cause problems when either programs become larger or we introduce new target properties where it is unclear what piece of code they reference. Let us have a look at the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/icyphy/lingua-franca/wiki/Writing-Reactors-in-Cpp#the-c-target-specification\"\n  }, \"existing target properties for C++\"), \". How should those different properites be handled on an import? Which scope do they actually apply to? We haven't really talked about this.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fast\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keepalive\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"threads\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \" are easy. They apply to the main reactor. Since we do not import main reactors from other files, it is clear that we really want to use the properties defined in the main compilation unit. So our current strategy works in this case. Although there are still some subtelties. For instance, if a library file defines \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keepalive=true\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fast=false\"), \" because it uses physical actions, should any file importing this library file be allowed to override these properties. Probably not, because it doesn't make sense if physical actions are involved. But a careless user of the library might not be aware of that. So maybe it isn't that clear after all.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"build-type\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cmake-include\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"compile\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"logging\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"no-runtime-validation\"), \" influence how the application is build. They are used for generating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CMakeLists.txt\"), \" file. So their is quite clear: they apply to the whole compilation of the given application. Again it is a simple solution to only consider the target properties of the file containing the main reactor since this can be considered the file that 'drives' the compilation. But what if an imported \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" relies on an external library and uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cmake-include\"), \" property to tell cmake to look this library up, make the library header files visible and link our generated code to that library (fortunately this can be done with 2 lines in cmake). Should this target property really be ignored by our import? Probably not, because it will lead to compile errors if the authot of the main \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file does not configure \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cmake-include\"), \" properly. So there should be some kind of merging mechanism for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cmake-include\"), \". Should this be done for the other properties as well? I am not sure and I actually don't know how the merging would work.\"), mdx(\"p\", null, \"So this raises a lot of questions that we currently have no answer to. I believe we need to find answers for these questions in order to create a well working import and package system. This gets only more complicated when we add more properties such as the proposed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"files\"), \" directive. We should really consider what properties actually apply to and if they influence the way imports work.\"), mdx(\"h3\", null, \"The work in progress\"), mdx(\"p\", null, \"To be continued... I want to describe here what is happening on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new_import\"), \" and the (potential) problems this brings.\"), mdx(\"h3\", null, \"Possible solutions\"), mdx(\"p\", null, \"To be continued... I would like to show a few possible soltions that have come to mind and that we discussed already.\"), mdx(\"h2\", null, \"Concrete proposal\"), mdx(\"p\", null, \"With the risk of overlooking some of the issues discussed above, I'd like to outline a concrete proposal. To me, at least, it is easier to reason about these issues in a context with a few more constraints. Hopefully, this can serve as a starting point that we can tweak/adjust as needed. Note: this proposal borrows from the previous proposal written by Soroush. Based on my experience with Xtext, I have confidence that what is described below is feasible to implement.\"), mdx(\"h3\", null, \"Import/export\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"One LF file can contain multiple reactor definitions.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There can be at most one main reactor per file.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Any reactor class defined outside of the current file has to be imported explicitly.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The visibility of a reactor class can be limited using a modifier in the class definition.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Should the default visibility be public or private? I have no strong preference either way.\"))), mdx(\"ol\", {\n    \"start\": 5\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"An \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"import\"), \" statement \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"must\"), \" specify which reactor classes to import. This is necessary because if we populate a global scope using the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"uriImport\"), \" mechanism, the local scope provider needs to know which definition to link to if there happen to exist multiple among the set of included files. We could \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"potentially\"), \" relax this constraint and only report the situation where we know for a fact that there is ambiguity and needs to be resolved by making the imports explicit. We could also deprecate the use of unqualified imports (the original syntax), therefore allow it but warn that it might not work as expected.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"An LF file in an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"import\"), \" statement is specified by a path relative to the directory of the file in which the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"import\"), \" statement occurs or relative to a series of directories in a wider search path.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Eclipse uses \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \".project\"), \" files to identify the root of a project; we can look for that.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"We can look for our own kind of manifest files as well. These can list additional locations to search. This is compatible with the idea of developing a package system. I personally like this approach better than using an environment variable.\"))), mdx(\"ol\", {\n    \"start\": 7\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"I personally find fully qualified names excess generality and have never felt compelled to use them in Java. IMO, they lead to code that's difficult to read and a pain to format. To keep things simple, I suggest we don't support them. Instead, we should provide a mechanism for renaming imported reactor classes to avoid naming conflicts.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Open question: do we want scope modifiers for imports? It seems that extra import statements could be used to increase visibility, so it might not be needed.\"))), mdx(\"h3\", null, \"Syntax\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Import := 'import' <ID> <Rename>? (',' <ID> <Rename>?)* 'from' <PATH>\\n\\nRename := 'as' <ID>\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note: This syntax could be extended to support packages in addition to paths. But it doesn't make much sense to have this until we have a package manager and package registry.\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Current state of the discussion: one unifying syntax vs. different syntax for references to files and packages.\")), mdx(\"h2\", null, \"Preambles\"), mdx(\"p\", null, \"A preamble allows for the inclusion of verbatim target code that may be necessary for reactors to function. Currently, there are two scopes in which preambles can appear: (1) file scope and (2) reactor class scope. Moreover, there exist visibility modifiers to label preambles \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"private\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public\"), \". A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public\"), \" preamble is intended to contain code that is necessary for the use of a reactor that is in scope. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"private\"), \" preamble is intended to contain code that is necessary for the implementation of a reactor that is in scope. Only the Cpp code generator can currently effectively separate these LF scope levels. It achieves this by putting each reactor class definition in its own file. LF file scope preambles are currently not supported by the C target, but this appears to be unintentional and would be easy to fix. Reactor class scope preambles are supported by the C target, but there is no isolation of scope; the preamble of one reactor is visible to the one defined after it. To fix this, I see two options: (1) follow the same approach as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CppGenerator\"), \" and output separate files, which also means that a Makefile has to be generated in order to compile the result, or (2) leverage block scope within a single file, but this will become complicated and make the generated C code even less humanly readable.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"We could put aside the problem of name clashes due to the absence of scope isolation in generated C code and fix this later. For the time being, the problem can be circumvented using \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \".h\"), \" files.\")), mdx(\"h2\", null, \"Target Properties\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Each file declares a target.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"All code in all reactors in the same file must agree with the specified target.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Additional target properties may be specified.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Target properties are not inherited through imports.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Any property that needs to be inherited through an import (such as the requirement to link against the pthread library) must be specified as a build dependency instead.\")), mdx(\"h2\", null, \"Build Dependencies\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It must be possible to specify build dependencies, such as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"files\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sources\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"protobufs\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We could either allow these definitions to go directly in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".lf\"), \" file, or we could decide to specify them in a package description (i.e., separate file). We could potentially allow both.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Build dependencies are inherited through imports (or from package descriptions), and they are never shadowed, always \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"joined\"), \".\")), mdx(\"h1\", null, \"Unique Reactor Names\"), mdx(\"p\", null, \"The new import system as described above ensures that reactor names within a single \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file are unique. In case reactors with the same name are imported from different \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" files, the renaming mechanism needs to be used in order to resolve the name conflict. The same applies if the given \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".lf\"), \" file defines some reactors and tries to import other reactors with the same name. For instance, consider the LF file in Example 1 below. In the scope of this file, three reactor declarations are visible: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Baz\"), \", although the actual reactors have the same name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \".\"), mdx(\"h2\", null, \"Examples\"), mdx(\"p\", null, \"Throughout this section, I will be using two LF example programs. Since the markdown syntax does not provide a simple way to label and refer to code listings, I figure its easiest to place them here in a central place and refer to them later by the heading\"), mdx(\"h3\", null, \"Example 1\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Foo.lf\\nimport Foo as Bar from \\\"Bar.lf\\\"\\nimport Foo as Baz from \\\"Baz.lf\\\"\\n\\nreactor Foo {\\n  \\\\\\\\ ...\\n}\\n\")), mdx(\"h3\", null, \"Example 2\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Baz.lf\\nreactor Foo {\\n  \\\\\\\\ ...\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Bar.lf\\nimport Foo from \\\"Baz.lf\\\"\\n\\nreactor Foo {\\n  foo = new Foo()\\n  \\\\\\\\ ...\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Foo.lf\\nimport Bar from \\\"Bar.lf\\\"\\nmain reactor Foo {\\n  bar = new Bar()\\n  \\\\\\\\ ...\\n}\\n\")), mdx(\"h2\", null, \"Unique Reactor Names in Target Code\"), mdx(\"p\", null, \"While the mechanism above effectively ensures uniqueness in a single LF file, this uniqueness is surprisingly hard to ensure in generated target code. C has an obvious problem here as it places all generated code in a single file. While the name conflict in the above code can be solved by generating code for three reactors named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Baz\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \", it breaks as soon as another file of the same LF program uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import Foo from \\\"Bar.lf\\\"\"), \". Then there would be two definitions of the reactor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" that cannot be resolved.\"), mdx(\"p\", null, \"Now you would probably expect that splitting the generated code into multiple files solves the issue, but unfortunately this is not true. If anything, it makes the problem more subtle. The C++ code generated from Example 1  would likely look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Foo.hh\\n#include <reactor-cpp/reactor-cpp.hh>\\n\\n#include \\\"Bar.hh\\\"\\n#include \\\"Baz.hh\\\"\\n\\n// do the renaming\\nusing Bar = Foo;\\nusing Baz = Foo;\\n\\nclass Foo : public reactor::Reactor {\\n};\\n\")), mdx(\"p\", null, \"This will cause a compile error as there are multiple definitions of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \". While renaming is possible in C++ with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"using\"), \" keyword (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typedef\"), \" works as well), the thing being renamed needs to be already visible in the scope. So there are multiple definitions of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" as all the files \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.hh\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Baz.hh\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.hh\"), \" define this class. We need a mechanism to distinguish the different definitions of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \".\"), mdx(\"p\", null, \"There is even another issue that stems from the fact that the semantics of imports in LF are different from the include semantics of C++. Consider the code in Example 2, which is valid LF code. Although \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.lf\"), \" imports \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" imports from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.lf\"), \", the definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Baz.lf\"), \" is not visible in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \". This 'hiding', however, does not easily propagate to the generated code. In C, there will be an error because both definitions of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" are placed in the same file. In C++, the different definitions of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" are placed in different files, but there will still be an error. The generated C++ code would look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Baz.hh\\n#include <reactor-cpp/reactor-cpp.hh>\\n\\nclass Foo : public reactor::Reactor {\\n  // ...\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Bar.hh\\n#include <reactor-cpp/reactor-cpp.hh>\\n\\n#include \\\"Baz.hh\\\"\\n\\nclass Bar : public reactor::Reactor {\\n  Foo foo;\\n  // ...\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Foo.hh\\n#include <reactor-cpp/reactor-cpp.hh>\\n\\n#include \\\"Bar.hh\\\"\\n\\nclass Foo : public reactor::Reactor {\\n  Bar bar;\\n  // ...\\n};\\n\")), mdx(\"p\", null, \"This will produce an error due to multiple definitions of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" being visible in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.hh\"), \". The problem is that any include in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bar.hh\"), \" becomes also visible in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.hh\"), \". So there is a name clash due to the way the C++ compiler processes included and that is hard to work around.\"), mdx(\"h2\", null, \"Possible Solutions\"), mdx(\"p\", null, \"In conclusion from the above section, I can say that translating the file based scoping of reactor names that we have in LF to generated target code is not trivial. Any sensible solution will need to establish a mechanism to ensure that any two distinct reactors in LF are also distinct in target code.\"), mdx(\"h3\", null, \"Namespaces\"), mdx(\"p\", null, \"We could introduce some form of a namespace mechanism that allows us to derive fully-qualified names of reactors. This is the preferred solution for me (Christian). Note that by 'namespace' I mean any logical organization of reactors in named groups and not the precise concept of C++ namespaces. In other languages those logical groups are also referred to as modules or packages. Also note that it is only important to be able to assign a fully-qualified name to a reactor, it does not necessarily require that we refer to reactors by their fully-qualified name in LF code.\"), mdx(\"h4\", null, \"File based namespaces\"), mdx(\"p\", null, \"In my view, the easiest way to introduce namespaces in LF would be to leverage file system structure. Everything contained in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" would automatically be in the namespace \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \". So the FQN of a reactor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" defined in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.Foo\"), \" (or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo::Foo\"), \", or some other delimiter). This would solve the name clashes in both of our examples. For Example 1, the generated code could look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// Foo.hh\\n#include <reactor-cpp/reactor-cpp.hh>\\n\\n#include \\\"Bar.hh\\\"\\n#include \\\"Baz.hh\\\"\\nnamespace Foo {\\n\\n// do the renaming\\nusing Bar = Bar::Foo;\\nusing Baz = Baz::Foo;\\n\\nclass Foo : public reactor::Reactor {\\n};\\n}\\n\")), mdx(\"p\", null, \"For Example 2, the generated code could look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Baz.hh\\n#include <reactor-cpp/reactor-cpp.hh>\\n\\nnamespace Baz {\\nclass Foo : public reactor::Reactor {\\n  // ...\\n};\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Bar.hh\\n#include <reactor-cpp/reactor-cpp.hh>\\n\\n#include \\\"Baz.hh\\\"\\n\\nnamespace Bar {\\nusing Foo = Baz::Foo; // bring Foo in scope\\n\\nclass Bar : public reactor::Reactor {\\n  Foo foo;\\n  // ...\\n};\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\\\\\\\ Foo.hh\\n#include <reactor-cpp/reactor-cpp.hh>\\n\\n#include \\\"Bar.hh\\\"\\n\\nnamespace Foo {\\nusing Bar = Bar::Bar; // bring Bar in scope\\n\\nclass Foo : public reactor::Reactor {\\n  Bar bar;\\n  // ...\\n};\\n}\\n\")), mdx(\"p\", null, \"While this appears to be a promising solution, it is not sufficient to only consider the name of an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*.lf\"), \" file to derive the namespace\\nThere could be two files \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo.lf\"), \" in different directories that both define the reactor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \". Thus, we also need to consider the directory structure and introduce hierarchical namespaces. Consider this directory tree:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"foo/\\n  bar/\\n    foo.lf  # defines reactor Foo\\n  baz/\\n    foo.lf  # defines reactor Foo\\n\")), mdx(\"p\", null, \"In this example, the two \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" reactors would have the fully qualified names \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo.bar.foo.Foo\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo.baz.foo.Foo\"), \".\\nIn order for this concept to work, we need the notion of a top-level namespace or directory. Naturally, this would be the package. Therefore, this namespace approach would also require a simple mechanism to define a package. For now this could be rudimentary. Simply placing an empty \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lf.yaml\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo/\"), \" directory in the above example would be sufficient. In addition to the notion of packages, we would also need a simple mechanism to find packages. However, since packages are something we want to have anyway, it would not hurt to start and implement a rudimentary system now.\"), mdx(\"p\", null, \"This proposal is a bit at odds with the file based import mechanism described above. While it is clear what the namespace of an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*.lf\"), \" file relative to a package directory is, it is unclear what the namespace of an arbitrary file outside a package is. Marten suggested to resolve this by using a default namespace or the global namespace whenever a *lf that is not part of a package is imported and to make the user responsible for avoiding any conflicts.\"), mdx(\"p\", null, \"We would also need to restrict the naming of files and directories and ban the usage of the namespace deliminator (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"::\"), \" or some other) in file and directory names. In my opinion this is not much of a problem and common practice for many languages. If we decide to use this namespace mechanism, it would probably be better to drop the file based imports and switch to imports by FQN (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import Foo from foo.bar.foo\"), \")\"), mdx(\"h4\", null, \"A Namespace Directive\"), mdx(\"p\", null, \"As an alternative to the file based namespace mechanism described above, we could also introduce a namespace directive in the LF syntax or as part of the target properties. This would effectively allow the user to specify the namespace that any reactor defined in a file should be part of. This solution would allow to augment the file based import system that we have with a namespace mechanism. It is important to note, however, that this entirely shifts the responsibility for ensuring uniqueness within a namespace to the user. When we derive namespaces from the file path as described above, we can be sure that the resulting namespace only contains unique reactors because we ensure that any LF file only contains unique reactors. If we allow the user to specify the namespace, however, there could easily be two files with the same namespace directive that both define the reactor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \". This approach might also cause problems for target langauages where the namespaces relate tp conrete file paths such as in Rust, Python or Java.\"), mdx(\"h3\", null, \"Name Mangling\"), mdx(\"p\", null, \"There are other mechanisms to derive unique names apart from namespaces. One that is widely used by compilers is name mangling which replaces or decorates the original name. For instance, we could simply add a number to the name of generated reactors (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo1\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo2\"), \", ...) to distinguish multiple LF reactor definitions named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \". What seperates our approach from traditional compiler though, is that we are not in control of the full build process and only generate source code to be processed by another compiler. Therefore, any renaming we do when compiling LF code to target code needs to be done with care as it could easily introduce new problems because we are not aware of all the identifiers defined in a target language. For instance if our LF program uses a library that defines the class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo3\"), \", adding a third definition of the reactor Foo to the prorgram would lead to an unexpected error that is also hard to debug.\"), mdx(\"p\", null, \"Soroush also proposed to use a hashing mechanism (for instance a hash of the file name) to decorate reactor names. This would be less likely\\nto clash with any names defined in some library. However, we would need to make sure that any mechansim we use for generating unique decorated names follows strict rulses and generates reproducable names. This reproducibility is crucial for several reasons. \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Since even a complex name mangling mechanism has still the chance to produce name clashes with identifiers defined outside of the LF program, those clashes should not occur randomly. There should be either an error or no error on each compilation run. Nondeterministic builds are no fun to deal with.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In case of any errors, it is crucial to be able to reproduce and compare builds across machines and platforms. A platform dependent name mangling algorithm (for instance one that hashes file paths) would make it unecessary hard to reproduce and debug compile errors.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Somewhere in the future, we might want to be able to compile packages as libraries. Recompilation of the library should never change its API. Moreover, the name mangling algorithm should be robust in the sense that small changes in LF code do not lead to changed identifiers\\nin the library API.\"))), mdx(\"p\", null, \"All in all, I think it is hard to define an algorith that generates reproducible and stable names, but maybe someone else has a good idea of how this could be achieved. \"), mdx(\"p\", null, \"Another obvious disadvantage of the name mangling approach would be that the generated code is less readable. Also any external target code that might want to reference reactors in a library compiled from LF code, would need to know and use the mangled name.\"), mdx(\"h2\", null, \"Unique Reactor Names in our Tools\"), mdx(\"p\", null, \"In our last meeting (Tue 2020-08-04), I said that there are other places where we care about unique names: our tools such as the diagram view or the trace generator that I implemented for C++ and that we cannot ensure that names are unique at the moment. However, while thinking about it a bit more I realized that this is not much of an issue. Ambiguous names of reactor types are not a big problem for the diagram view. Since clicking on the nodes jumps directly to the reactor definition, the ambiguity in the names can easily be resolved.\"), mdx(\"p\", null, \"For the tracing, I realized that it is not the name of the reactor type that matters, but the name of the instance. These are unique fully-qualified names already. For instance \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main.foo.bar.r0\"), \", denotes the reaction with priority 0, of a reactor instance called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar\"), \" that is contained by the reactor instance \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \", which is in turn contained by the main reactor.\"), mdx(\"h2\", null, \"Summary\"), mdx(\"p\", null, \"All in all, I think leveraging the file strucuture for determining the fully qualified names of reactors is the most promising solution.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It works without any changes in our syntax. Only the code generators need to be updated to support the namespacing.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In contrast to name mangling, it allows generation of readable code and also gives the programmer full control of how generated reactors are named.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It fits naturally to languages that also support leveraging the file structure to create namespaces (e.g. python or rust).\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#the-status-quo","title":"The status quo","items":[{"url":"#a-quick-dive-into-the-c-code-generator","title":"A quick dive into the C++ code generator"},{"url":"#the-problem-with-preambles","title":"The problem with preambles"},{"url":"#the-problem-with-target-properties","title":"The problem with target properties","items":[{"url":"#the-work-in-progress","title":"The work in progress"},{"url":"#possible-solutions","title":"Possible solutions"}]},{"url":"#concrete-proposal","title":"Concrete proposal","items":[{"url":"#importexport","title":"Import/export"},{"url":"#syntax","title":"Syntax"}]},{"url":"#preambles","title":"Preambles"},{"url":"#target-properties","title":"Target Properties"},{"url":"#build-dependencies","title":"Build Dependencies"}]},{"url":"#unique-reactor-names","title":"Unique Reactor Names","items":[{"url":"#examples","title":"Examples","items":[{"url":"#example-1","title":"Example 1"},{"url":"#example-2","title":"Example 2"}]},{"url":"#unique-reactor-names-in-target-code","title":"Unique Reactor Names in Target Code"},{"url":"#possible-solutions-1","title":"Possible Solutions","items":[{"url":"#namespaces","title":"Namespaces","items":[{"url":"#file-based-namespaces","title":"File based namespaces"},{"url":"#a-namespace-directive","title":"A Namespace Directive"}]},{"url":"#name-mangling","title":"Name Mangling"}]},{"url":"#unique-reactor-names-in-our-tools","title":"Unique Reactor Names in our Tools"},{"url":"#summary","title":"Summary"}]}]},"parent":{"relativePath":"A-future-proof-package-and-import-system.md"},"frontmatter":{"metaTitle":null,"metaDescription":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Benchmarks","title":"Benchmarks"}}},{"node":{"fields":{"slug":"/A-future-proof-package-and-import-system","title":"A Future Proof Package And Import System"}}},{"node":{"fields":{"slug":"/Clone-the-Repository","title":"Clone The Repository"}}},{"node":{"fields":{"slug":"/Containerized-Execution","title":"Containerized Execution"}}},{"node":{"fields":{"slug":"/Contributing","title":"Contributing"}}},{"node":{"fields":{"slug":"/Creating-and-Managing-Submodules","title":"Creating And Managing Submodules"}}},{"node":{"fields":{"slug":"/Developer-IntelliJ-Setup-(for-Kotlin)","title":"Developer Intelli J Setup For Kotlin"}}},{"node":{"fields":{"slug":"/Diagrams","title":"Diagrams"}}},{"node":{"fields":{"slug":"/Distributed-Execution","title":"Distributed Execution"}}},{"node":{"fields":{"slug":"/Generic-Types,-Interfaces,-and-Inheritance","title":"Generic Types Interfaces And Inheritance"}}},{"node":{"fields":{"slug":"/Downloading-and-Building","title":"Downloading And Building"}}},{"node":{"fields":{"slug":"/Home","title":"Home"}}},{"node":{"fields":{"slug":"/Import-System","title":"Import System"}}},{"node":{"fields":{"slug":"/Legacy-Eclipse-Instructions","title":"Legacy Eclipse Instructions"}}},{"node":{"fields":{"slug":"/Maven-Notes","title":"Maven Notes"}}},{"node":{"fields":{"slug":"/Modal-Models-RFC","title":"Modal Models RFC"}}},{"node":{"fields":{"slug":"/Multiports-and-Banks-of-Reactors","title":"Multiports And Banks Of Reactors"}}},{"node":{"fields":{"slug":"/Overview","title":"Overview"}}},{"node":{"fields":{"slug":"/Protobufs","title":"Protobufs"}}},{"node":{"fields":{"slug":"/Publications-and-Presentations","title":"Publications And Presentations"}}},{"node":{"fields":{"slug":"/Regression-Tests","title":"Regression Tests"}}},{"node":{"fields":{"slug":"/Related-Work","title":"Related Work"}}},{"node":{"fields":{"slug":"/Results-of-Experiments-for-Rhythm","title":"Results Of Experiments For Rhythm"}}},{"node":{"fields":{"slug":"/Running-Benchmarks","title":"Running Benchmarks"}}},{"node":{"fields":{"slug":"/Running-Lingua-Franca-IDE-(Epoch)-with-Kotlin-based-Code-Generators-Enabled-(without-Eclipse-Environment)","title":"Running Lingua Franca IDE Epoch With Kotlin Based Code Generators Enabled Without Eclipse Environment"}}},{"node":{"fields":{"slug":"/Support-Matrix","title":"Support Matrix"}}},{"node":{"fields":{"slug":"/Tardiness","title":"Tardiness"}}},{"node":{"fields":{"slug":"/Target-Specification","title":"Target Specification"}}},{"node":{"fields":{"slug":"/Termination","title":"Termination"}}},{"node":{"fields":{"slug":"/Timing-Analysis","title":"Timing Analysis"}}},{"node":{"fields":{"slug":"/Tools","title":"Tools"}}},{"node":{"fields":{"slug":"/Troubleshooting","title":"Troubleshooting"}}},{"node":{"fields":{"slug":"/Using-Maven","title":"Using Maven"}}},{"node":{"fields":{"slug":"/Web-Based-Editor","title":"Web Based Editor"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Cpp","title":"Writing Reactors In Cpp"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-Python","title":"Writing Reactors In Python"}}},{"node":{"fields":{"slug":"/","title":"Landing Page"}}},{"node":{"fields":{"slug":"/Writing-Reactors-in-TypeScript","title":"Writing Reactors In Type Script"}}}]}},"pageContext":{"id":"8965a35a-796e-5961-8628-01080b13f007"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}